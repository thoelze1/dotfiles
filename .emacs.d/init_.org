#+TITLE: Tanner's Emacs Config
#+PROPERTY: header-args :results none

This file gets loaded from [[file:init.el][~init.el~]] and configures emacs to my liking
across a variety of systems.

When your init file is non-literate, you are forced to separate your            
configuration into multiple files, adding complexity. With literate
org, you are able to organize and even do away with the overhead of
additional org keywords (~#+begin_src~, etc) by using formatting, such
as colored code blocks!

* Documentation

* To Do
- Assign hotkey to open the messages buffer
- Hotkey emacs directory node
  
* Generic routines
#+begin_src emacs-lisp
  (defun set-to-original (var)
    (set var (eval (car (get var 'standard-value)))))
#+end_src
* Startup
It is possible to declare the initial buffer with
~initial-buffer-choice~.

#+begin_src emacs-lisp
  (setq inhibit-splash-screen t)
#+end_src

* Package management
There are several ways to manage emacs packages, both within and
without emacs. A quick primer from a [[https://www.reddit.com/r/emacs/comments/fxry79/comment/fmw514b/][reddit comment]]:
- Melpa and GNU Elpa are two websites hosting packages.
- ELPA stands for Emacs Lisp Package Archive.
- package.el is the client for ELPA.
- use-package is not a package manager, for example, you can't upgrade
  and delete package with it, though it provides builtin wrapper for
  installing package using package.el. I treat use-package as
  progn. One issue on use-package is that the code was too difficult
  for me to understand and I believe don't put anything I can't
  understand in my init file, and my use of use-package breaks the
  rule.
- straight.el is another package manager. It doesn't download packages
  from GNU Elpa or Melpa.

** Within Emacs
There are various package managers within Emacs. Emacs has a built-in
package manager, ~package.el~. ~use-package~ is a wrapper for
~package.el~. ~straight.el~ is another package manager.

*** package.el
By default, its sole repository is GNU's [[https://elpa.gnu.org][ELPA]] (Emacs Lisp Package
Archive), but we can just add some of our own:

#+begin_src emacs-lisp
  (require 'package)
  (set 'package-archives '(("gnu" . "https://elpa.gnu.org/packages/")))
  (add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/") t)
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
  (add-to-list 'package-archives '("nongnu" . "https://elpa.nongnu.org/nongnu/") t)
#+end_src

At this point, we can select packages for installation using the
~package-selected-packages~ variable, install those packages with
~package-install-selected-packages~, and load them with
~package-initialize~. Then, packages can be used right away just by
using them, or by explicitly using ~require~:

#+begin_src emacs-lisp :tangle no
  (setq package-selected-packages
        '(org-roam
          minibuffer-line
          fancy-battery
          xelb
          haskell-mode
          geiser
          ox-twbs
          yasnippet
          exwm
          htmlize
          org-babel-eval-in-repl
          paredit
          zenburn-theme
          avy
          slime
          sicp
          multiple-cursors
          exec-path-from-shell
          magit))
  (package-install-selected-packages)
  (package-initialize)
#+end_src

Doing this, however, separates the package installation,
loading, and configuration which defeats encapsulation and
scales poorly across machines. Instead, we can use ~use-package~:

*** use-package
#+begin_src emacs-lisp
  (when (not (package-installed-p 'use-package))
    (package-refresh-contents)
    (package-install 'use-package))
#+end_src

Now, ~use-package~ loads packages for use! In fact, ~use-package~ can
abstract not only package loading, but also package installation:

#+begin_src emacs-lisp
  (require 'use-package-ensure)
  (setq use-package-always-ensure t)
#+end_src

The benefits of use-package are package pinning and automatic
installation. See [[https://www.reddit.com/r/emacs/comments/8ua8e6/is_it_possible_specify_repository_preference_with/][this reddit thread]] for more.

*** straight.el
When I first ran this, it hung emacs. I had to quit and then on the
next execution it worked:
#+begin_src emacs-lisp
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 6))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+end_src
I also added a line to ~early-init.el~.

**** Uninstallation
All you have to do is remove the straight-use-package line! Very cool:
https://systemcrafters.net/advanced-package-management/using-straight-el/
** Within Guix
I don't yet have a good reason to manage my Emacs packages in
Guix. Managing packages within Emacs has the benefit of simplicity and
portability, so I'll continue managing packages in Emacs until there's
a good reason not to.

** Local Elisp
Any local 
#+begin_src emacs-lisp
  ; Local packages
  ;; Tell emacs where other config files are
  (setq site-lisp-dir
        (expand-file-name "site-lisp" user-emacs-directory))
  (add-to-list 'load-path site-lisp-dir)
  ;; Add local projects to load path
  (dolist (project (directory-files site-lisp-dir t "\\w+"))
    (when (file-directory-p project)
      (add-to-list 'load-path project)))
  (require 'spotify)
  (require 'vimgolf)
#+end_src

* Completion
Use company mode in all buffers:
#+begin_src emacs-lisp
  (use-package company :pin gnu)
  ;(add-hook 'after-init-hook 'global-company-mode) ;; off because buggy in clj
#+end_src

* Project management
Use projectile everywhere:
#+begin_src emacs-lisp
  (use-package projectile :pin melpa-stable)
  (projectile-mode +1)
  (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
#+end_src

* Debugging
#+begin_src emacs-lisp
  (setq debug-on-error t)
#+end_src

* Dired
Not sure what auto revert-mode is, I'll have to come back and document
this.

~toggle-truncate-lines~ is because wrapped lines are super ugly
because dired is dumb
#+begin_src emacs-lisp
  (add-hook 'dired-mode-hook 'auto-revert-mode)
  (setq-default auto-revert-verbose nil)
  (add-hook 'help-mode-hook 'auto-revert-mode) ;; doesn't work
  (global-auto-revert-mode)
  (add-hook 'dired-mode-hook (lambda () (toggle-truncate-lines 1)))
  (add-hook 'dired-mode-hook #'dired-hide-details-mode)
#+end_src

Use ~dired-hide-details-mode~, bound to ~(~, to toggle long-list
format.

* LISP interaction
Let's highlight matching parens. ~blink-matching-parens~ controls
highlighting of parens immediately after insertion; ~show-paren-mode~
is a minor mode that controls highlighting of parens based on cursor
placement:
#+begin_src emacs-lisp
(show-paren-mode 1)
#+end_src
Use this to refactor adding of hooks:
#+begin_src emacs-lisp
    (setq lisp-mode-hooks '(scheme-mode-hook
                            emacs-lisp-mode-hook
                            clojure-mode-hook
                            cider-repl-mode-hook))
    (defun add-to-multiple-hooks (hooks function)
      (mapc (lambda (hook) (add-hook hook function)) hooks))
#+end_src
** Scheme
#+begin_src emacs-lisp
  (use-package geiser :pin nongnu)
  (use-package geiser-guile :pin nongnu)
#+end_src
** Paredit
#+begin_src emacs-lisp
  (add-to-multiple-hooks lisp-mode-hooks #'enable-paredit-mode)
#+end_src
#+begin_src emacs-lisp
  (defun my-paredit-shove-back ()
    "Like paredit-forward-slurp-sexp, but with point on the sexp to
  be slurped rather than the sexp to be slurped into."
    (interactive)
    (save-excursion
      (paredit-backward)
      (paredit-forward-down)
      (paredit-forward-slurp-sexp)))
#+end_src
#+begin_src emacs-lisp
  (add-hook 'paredit-mode-hook
	    (lambda () (local-set-key (kbd "C-M-(") #'paredit-wrap-round)))
#+end_src
** Rainbow Parens
#+begin_src emacs-lisp
  (use-package rainbow-delimiters :pin melpa-stable)
  (add-to-multiple-hooks lisp-mode-hooks #'rainbow-delimiters-mode)
#+end_src
** Clojure/ClojureScript
#+begin_src emacs-lisp
  (defvar etags-clj-cljs-regexp
    (concat "etags " "--regex='/[ \t\(]*def[a-z]* \([a-z!-]+\)/\1/' "
                     "--regex='/[ \t\(]*ns \([a-z.]+\)/\1/'"))

  ;; Recursively generate tags for all *.clj files, 
  ;; creating tags for def* and namespaces
  (defun create-clj-tags (dir-name)
    "Create tags file."
    (interactive "DDirectory: ")
    (shell-command
     (format "find %s \! -name '.*' -name '*.clj' | xargs %s"
             dir-name etags-clj-cljs-regexp)))

  ;; Recursively generate tags for all *.cljs files, 
  ;; creating tags for def* and namespaces
  (defun create-cljs-tags (dir-name)
    "Create tags file."
    (interactive "DDirectory: ")
    (shell-command
     (format "find . \! -name '.*' -name '*.cljs' | xargs %s"
             etags-clj-cljs-regexp)))

  ;; Recursively generate tags for all *.clj and *.cljs files, 
  ;; creating tags for def* and namespaces
  (defun create-clj-cljs-tags (dir-name)
    "Create tags file."
    (interactive "DDirectory: ")
    (shell-command
     (format "find %s \! -name '.*' -name '*.clj' -name '*.cljs' | xargs %s"
             dir-name etags-clj-cljs-regexp)))
#+end_src
#+begin_src emacs-lisp
  (use-package html-to-hiccup)
#+end_src
#+begin_src emacs-lisp
  (use-package clojure-mode)
  (use-package cider)
  (setq nrepl-use-ssh-fallback-for-remote-hosts 't)
#+end_src
#+begin_src emacs-lisp
  (add-hook 'clojure-mode-hook
            (lambda ()
              (set-fill-column 80)))
#+end_src
* Templates
#+begin_src emacs-lisp
  (use-package yasnippet)
  (setq yas-snippet-dirs '("~/.emacs.d/snippets"))
  (add-hook 'scheme-mode-hook #'yas-minor-mode)
  (yas-reload-all)
  (yas-global-mode 1)
#+end_src

* Autocompletion (helm)
#+begin_src emacs-lisp
  (use-package helm-core :pin melpa-stable)
  (use-package helm :pin melpa-stable)
  (global-set-key (kbd "M-x") #'helm-M-x)
  (global-set-key (kbd "C-x r b") #'helm-filtered-bookmarks)
  (global-set-key (kbd "C-x C-f") #'helm-find-files)
  (global-set-key (kbd "C-x b") #'helm-buffers-list)
  (helm-mode 1)
#+end_src

I use helm-org for ~helm-org-agenda-files-headings~
#+begin_src emacs-lisp
  (use-package helm-org)
#+end_src

* Desktop interaction
#+begin_src emacs-lisp
  ;;(setq-default mode-line-format nil)

  (setq temp-max 25000)
  (setq temp-min 1000)
  (setq temp-default 2500)
  (setq temp-step 100)
  (setq temp temp-default)

  (setq brightness-default 0.5)
  (setq brightness brightness-default)
  (setq brightness-step 0.05)
  (setq brightness-max 1.0)
  (setq brightness-min 0.1)

  (defun temp-string () (format "%dK" temp))

  (defun redshift-update ()
    (start-process "" nil "redshift" "-P"
                   "-O" (temp-string)
                   "-b" (number-to-string brightness)))

  ;; What's a more lispy way of doing these redshift increment/decrement
  ;; functions? A HOF that does a "bounded-add"? 
  (defun temp-increment ()
    (interactive)
    (setq temp (min (+ temp temp-step)
                    temp-max))
    (redshift-update)
    (minibuffer-line--update))

  (defun temp-decrement ()
    (interactive)
    (setq temp (max (- temp temp-step)
                    temp-min))
    (redshift-update)
    (minibuffer-line--update))

  (defun brightness-increment ()
    (interactive)
    (setq brightness (min (+ brightness brightness-step)
                          brightness-max))
    (redshift-update)
    (minibuffer-line--update))

  (defun brightness-decrement ()
    (interactive)
    (setq brightness (max (- brightness brightness-step)
                          brightness-min))
    (redshift-update)
    (minibuffer-line--update))
  (setq minibuffer-line-refresh-interval 1)

  (setq minibuffer-line-format
          '(" "
           (:eval
            (format-time-string "%m/%d/%Y %T"))
           " | 🔋 "
           (:eval
            (battery-format "%p" (funcall battery-status-function)))
           "%% | "
           (:eval
            (format "%.2d" (* brightness 100)))
           "%% | "
           (:eval (temp-string))
           " | "
           ))

  ;;(setq mode-line-format nil)
  (setq-default mode-line-format '("%e" mode-line-front-space mode-line-mule-info mode-line-client mode-line-modified mode-line-remote mode-line-frame-identification mode-line-buffer-identification "   " mode-line-position
                           (vc-mode vc-mode)
                           "  " mode-line-modes mode-line-misc-info mode-line-end-spaces))
  #+end_src

* Appearance
If these are put in early-init.el then the frame briefly appears as
less than full screen, then expands (when starting with
emacsclient, at least). if started with emacs, then the frame stays
invisible.

#+begin_src emacs-lisp :tangle no
  (add-to-list 'initial-frame-alist '(visibility . nil))
  (add-to-list 'default-frame-alist '(fullscreen . maximized))
#+end_src

#+begin_src emacs-lisp
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (if (string-equal system-type "darwin")
      (progn
        (add-to-list 'default-frame-alist '(font . "SF Mono-12"))
        (add-to-list 'default-frame-alist '(undecorated . t))
        (add-to-list 'default-frame-alist '(fullscreen . maximized))))
  ;; set transparency
  ;; https://lwn.net/Articles/88179/
  ;; first value is for active frame, second value is for inactive frame
  ;; (set-frame-parameter (selected-frame) 'alpha '(99 100))
  (setq ring-bell-function 'ignore)
#+end_src

#+begin_src emacs-lisp
(set-frame-parameter nil 'width 100)
#+end_src
#+begin_src emacs-lisp
  (use-package zenburn-theme
    :defer t)
  (load-theme 'zenburn t)
#+end_src

For some reason, this is causing problems, so I'm not exporting it:
#+begin_src emacs-lisp :tangle no
  (require 'font-lock)
  (use-package font-lock
    :init
    :custom-face
    (font-lock-comment-face ((t (:inherit font-lock-comment-face :italic t))))
    (font-lock-doc-face ((t (:inherit font-lock-doc-face :italic t))))
    (font-lock-string-face ((t (:inherit font-lock-string-face :italic t)))))
#+end_src

* Avy
See https://github.com/abo-abo/avy/wiki/defcustom.

#+begin_src emacs-lisp
  (setq avy-keys '(?f ?j ?d ?k ?s ?l ?a ?\; ?' ?v ?n ?c ?m ?x ?, ?z
		   ?. ?b ?/ ?t ?u ?r ?i ?e ?o ?w ?p ?q ?\[ ?5 ?7 ?4
		   ?8 ?3 ?9 ?2 ?0 ?1 ?- ?6 ?= ?\] ?\\ ?` ?F ?J ?D ?K
		   ?S ?L ?A ?: ?\" ?V ?N ?C ?M ?X ?< ?Z ?> ?B ?? ?T
		   ?U ?R ?I ?E ?O ?W ?P ?Q ?{ ?% ?& ?$ ?* ?# ?\( ?@
		   ?\) ?! ?_ ?^ ?+ ?} ?| ?~))
  (setq avy-case-fold-search nil)
  (global-set-key (kbd "H-j") 'avy-goto-char)
#+end_src

* Whitespace (tabs, spaces, newlines)
** Indentation
The dumb way:
#+begin_src emacs-lisp
  (setq-default c-basic-offset 4)
  (setq-default indent-tabs-mode nil)
  (setq-default indicate-empty-lines t)
  (setq-default web-mode-attr-value-indent-offset 2)
  (setq-default web-mode-sql-indent-offset 2)
  (setq-default web-mode-attr-indent-offset 2)
  (setq-default web-mode-markup-indent-offset 2)
  (setq-default web-mode-code-indent-offset 2)
#+end_src

We can also infer:
#+begin_src emacs-lisp
  (use-package dtrt-indent :pin melpa-stable)
  ;;(add-hook 'prog-mode-hook (lambda () (dtrt)
  (dtrt-indent-global-mode)
#+end_src

** Final Newline (EOF)
Many language modes set ~require-final-newline~ from
~mode-require-final-newline~, which is ~t~ by default. I'm not sure
why certain languages require a newline at EOF. Anyways, when these
major modes enforce this final newline, it pollutes commits.
#+begin_src emacs-lisp
  (setq mode-require-final-newline nil)
#+end_src

* Enable functions
#+begin_src emacs-lisp
  (put 'narrow-to-region 'disabled nil)
  (put 'upcase-region 'disabled nil)
#+end_src

* ~customize~
Emacs has a "customization" feature allowing customizing certain
features through an interface. It can save those customizations to
your config, albeit in an opaque way. When using a literate org
config, any customizations automatically saved to the config will be
overwritten. So, we need to keep these in a safe place:
#+begin_src emacs-lisp
  (setq custom-file (concat user-emacs-directory "/custom.el"))
#+end_src
Now we can safely use ~customize~! Still, a separate file to dump
nameless customizations is anithetical to a literate config. I'll look
for a better way.

* Backups and  autosaves
Emacs uses "autosaves" and "backups" to prevent unintended loss of
work. An autosave periodically saves the buffer of an open file, so
that work not-yet-written to the filesystem is retained in the event
that emac crashes. A backup is a copy of a file that you have written
to, from emacs, that ensures you retain the original file in the event
of an accidental file overwrite. We definitely want to keep both these
features, but we want to store all of the autosaves and backups in one
place so that they don't clutter up the filesystem:

#+begin_src emacs-lisp
  (setq backup-directory-alist `(("." . "~/.emacs.d/.backups"))
        auto-save-file-name-transforms `((".*", "~/.emacs.d/.autosaves/\\1" t)))
  (setq desktop-path '("~/.emacs.d/desktop"))
  (setq auto-save-interval 150)
#+end_src

* Persistence between sessions
#+begin_src emacs-lisp
  (desktop-save-mode 1)
#+end_src
* Keyboard Setup
** Hyper
Once we add the ~hyper~ modifier Note how many bindings we can have
for number keys! First, we have 10 number keys and 10 numbered
function keys. We then have 5 modifiers (control, shit, meta, super,
hyper) which can be chorded, and then for the function-number keys
(f1, f2 etc) we have 4 modifiers! Supposing we can reasonably use 3
modifiers with a keypress, that's 1 + 5 + 10 + 10 = 26 ways of
pressing a number key, and 1 + 5 + 10 = 15 ways of pressing a numbered
function key for a total of 26 + 15 = 41 ways of pressing a generic
"number" key. Insane!

*** MacOS
I have karabiner map space to fn globally. I then have emacs map fn to
hyper. However, OSX translates some keychords containing fn into
keychords without the fn key. I know of two such cases: fn+f3
translates to f3 (as do the other numbered fn keys) and fn+<left>
translates to <home> (the other arrows keys have similar
translations). Therefore, some of the keybindings below use the the
translation from OSX instead of a chord with H (<home> instead of
<H-left>, for example)

#+begin_src emacs-lisp
  (if (string-equal system-type "darwin")
      (setq ns-function-modifier 'hyper))
#+end_src

*** GNU/Linux
#+begin_src emacs-lisp
  (if (string-equal system-type "gnu/linux")
      (setq ns-right-control-modifier 'hyper))
#+end_src

** ASCII Redundancies
Since we're *never* (hopefully) in a TTY, we want to free up control
codes that correspond to characters that already exist on the
keyboard. Maybe one day when I switch to a 40% I'll go back on this,
but for now it would be cool to free up these keybindings.

But actually, it turns out doing so is a [[https://emacs.stackexchange.com/a/52334][huge fucking rabbit hole]], and
so I won't (dare to) proceed until I have reason to. 

* Git
#+begin_src emacs-lisp
  (use-package magit :pin melpa-stable)
  (global-set-key (kbd "H-g") 'magit-status)
  (setq magit-diff-paint-whitespace t)
  (setq magit-diff-paint-whitespace-lines 'all)
  (setq magit-diff-highlight-trailing t)
  (setq magit-diff-highlight-indentation '())

#+end_src
Get a complete view of the directory in the status buffer by
displaying extant files ignored by git:
#+begin_src emacs-lisp
  (add-hook 'magit-status-sections-hook 'magit-insert-ignored-files)
#+end_src
** Auto commit'ing
I use this for [[id:C01F75C8-ACDE-4236-A06F-2FAFA930EFD4][my zettel]].
#+begin_src emacs-lisp
  (use-package git-auto-commit-mode :pin melpa-stable)
#+end_src
As per the docs, I added a .dir-locals.el to my git repo. I also
needed to adjust the default commit message. By default, the repo
starts with ~buffer-file-name~ which is the absolute path to the file
the buffer is visiting, then does some more transformation. I just
want the file name relative to the git directory. Below, the argument
is the absolute path:
#+begin_src emacs-lisp
  (defun gac-adjust-filename (filename)
    (file-relative-name filename "/Users/tannerhoelzel/Dropbox/org-roam/"))
  (setq gac-default-message 'gac-adjust-filename)
#+end_src

* Buffers
Don't do this:
#+begin_src emacs-lisp :export none
  (global-set-key (kbd "s-k") 'kill-this-buffer)
#+end_src
Documentation says is can silently do nothing. Instead do this:
#+begin_src emacs-lisp
  (global-set-key (kbd "s-k") 'kill-current-buffer)
#+end_src
** Windows
#+begin_src emacs-lisp
  (global-set-key (kbd "s-0") 'delete-window)
  (global-set-key (kbd "s-1") 'delete-other-windows)
  (global-set-key (kbd "s-2") 'split-window-below)
  (global-set-key (kbd "s-3") 'split-window-right)
  (global-set-key (kbd "<S-f3>") 'kmacro-end-macro)
  (global-set-key (kbd "H-c") 'mc/edit-lines)
  (global-set-key (kbd "s-f") 'make-frame)
  (global-set-key (kbd "s-n") 'other-window)
  (defun prev-window ()
    (interactive)
    (other-window -1))
  (global-set-key (kbd "s-p") 'prev-window)
  (global-set-key (kbd "s-o") 'find-file)
  (global-set-key (kbd "s-[") 'previous-buffer)
  (global-set-key (kbd "s-]") 'next-buffer)
  (defun next-window-next-buffer ()
    (interactive)
    (other-window 1)
    (next-buffer)
    (prev-window))
  (defun next-window-prev-buffer ()
    (interactive)
    (other-window 1)
    (previous-buffer)
    (prev-window))
  (global-set-key (kbd "s-{") 'next-window-prev-buffer)
  (global-set-key (kbd "s-}") 'next-window-next-buffer)
#+end_src

The =s=-={= and =s=-=}= bindings don't work due to my macbook keyboard
rollover, but these do:

#+begin_src emacs-lisp
  (global-set-key (kbd "<C-s-268632091>") 'next-window-prev-buffer)
  (global-set-key (kbd "<C-s-268632093>") 'next-window-next-buffer)
#+end_src

*** EXWM
#+begin_src emacs-lisp
  (if (string-equal system-type "gnu/linux")
      (progn
        ;;(require 'exwm-systemtray)
        ;;(exwm-systemtray-enable)
        ;;(setq exwm-systemtray-height 16)
        (require 'exwm)
        (require 'exwm-config)
        (exwm-config-default)
        (exwm-enable)
        ;;(setq fancy-battery-show-percentage t)
        ;;(fancy-battery-mode)
        (exwm-input-set-key (kbd "<XF86MonBrightnessDown>")
                      (lambda ()
                        (interactive)
                        (shell-command "light -U 5; light")))
        (exwm-input-set-key (kbd "<XF86MonBrightnessUp>")
                      (lambda ()
                        (interactive)
                        (shell-command "light -A 5; light")))      
        (exwm-input-set-key (kbd "<XF86MonBrightnessDown>") 'brightness-decrement)
        (exwm-input-set-key (kbd "<XF86MonBrightnessUp>") 'brightness-increment)
        (exwm-input-set-key (kbd "<S-XF86MonBrightnessDown>") 'temp-decrement)
        (exwm-input-set-key (kbd "<S-XF86MonBrightnessUp>") 'temp-increment)))
#+end_src

* Org
First some org-wide defaults.

#+begin_src emacs-lisp
  (setq org-directory "~/Dropbox/")
  (add-hook 'org-mode-hook 'turn-on-auto-fill)
  (add-hook 'org-mode-hook 'org-indent-mode) ; does this toggle?
  (setq org-src-tab-acts-natively t) ;; Src block indentation was horrible
  (setq org-src-window-setup 'current-window)
  (setq org-refile-targets '((org-agenda-files :maxlevel . 4)))
  (setq org-refile-use-outline-path nil)
  (org-babel-do-load-languages
   'org-babel-load-languages '((scheme . t)))
  (setq org-list-allow-alphabetical t)
  (setq org-startup-folded 'fold)
#+end_src

- TODO look into org-tempo and fix this
#+begin_src emacs-lisp :tangle no
  (add-to-list 'org-structure-template-alist
               '("el" . "#begin_src emacs-lisp\n?\n#end_src"))
#+end_src
Add org-entities. See https://emacs.stackexchange.com/questions/36898/proper-way-to-add-to-org-entities-user
#+begin_src emacs-lisp
  (setq org-entities-user
        '(("apple" "\\cmdkey" nil "&#8984;" "<kbd>COMMAND</kbd>" "<kbd>COMMAND</kbd>" "⌘")))
  ;; https://emacs.stackexchange.com/questions/7323/how-to-add-new-markup-to-org-mode-html-export
  (setq org-html-text-markup-alist '((code . "<kbd>%s</kbd>")))
#+end_src

Display keyboard input properly in html: https://emacs.stackexchange.com/questions/7323/how-to-add-new-markup-to-org-mode-html-export
#+begin_src emacs-lisp
  (setq org-html-text-markup-alist '((code . "<kbd>%s</kbd>")))
#+end_src

Let's organize headings with tags:
#+begin_src emacs-lisp
  (setq org-tag-alist
        '(("emacs" . ?e)
          ("money" . ?m)
          ("social" . ?s)
          ("chore" . ?c)
          ("exercise" . ?x)
          ("chelm")))
#+end_src

#+begin_src emacs-lisp :tangle no
(use-package org-contrib)
(require 'ol-git-link)
#+end_src

#+begin_src emacs-lisp
  (setq org-special-ctrl-a/e t)
  (setq org-special-ctrl-k t) ; This isn't working
#+end_src

#+begin_src emacs-lisp
  (setq org-goto-interface 'outline-path-completion)
#+end_src

Split code blocks with ~org-babel-demarcate-block~.

** Keybindings
Some good keybindings:
- =C=-=c= ='= for ~org-edit-special~

#+begin_src emacs-lisp
  (add-hook 'org-mode-hook
            (lambda ()
              (local-set-key (kbd "<C-M-return>") 'org-insert-subheading)))
  (global-set-key (kbd "H-c") 'org-capture)
  (global-set-key (kbd "C-c c") 'org-capture)
  (global-set-key (kbd "C-c r") 'org-refile)
  (global-set-key (kbd "C-c a") 'org-agenda)
#+end_src

** Org Babel
The manual says this is dangerous, but let's do it anyway:

#+begin_src emacs-lisp
  (setq org-confirm-babel-evaluate nil)
#+end_src

Source blocks are awesome, they even support diff's

** Org Cite
As of 2021 a builtin alternative to org-ref. To use it you must first
generate a bibliography perhaps by using org-bibtex (which is also
builtin). For testing purposes I pulled a [[id:CFE0AE0B-CAB3-4794-895F-F2B46DEEB912][BibTeX]] database
#+begin_src bibtex
  @book{friends,
    title = {​{​{LaTeX}​​} and Friends},
    author = {van Dongen, M.R.C.},
    date = {2012},
    location = {Berlin},
    publisher = {Springer},
    doi = {10.1007/978-3-642-23816-1},
    isbn = {978-3-642-23816-1}
  }
#+end_src
from
https://www.miskatonic.org/2024/01/08/org-citations-basic/. Once you
have your bibliography, you would refer to it either globally:
#+begin_src emacs-lisp
  (setq org-cite-global-bibliography '("/Users/tannerhoelzel/roam.bib"))
#+end_src
or using a file-local variable ~+bibliography:~ and then
~org-cite-insert~ to insert the citation.

** Org Capture
I want to be able to put the cursor exactly one line below the optional properties
drawer. Using two newlines in the template almost works, but creates
two newlines.
#+begin_src emacs-lisp
    (setq org-capture-templates-old
                  '(("s" "SICP Exercise" entry
                     (file "~/git/thoelze1.github.io/org/sicp-exercises.org")
                     "* %?")
                    ("j" "Journal" entry
                     (file (lambda () (concat org-directory "journal.org")))
                     "* %U\n%?" :clock-in t :clock-resume t)
                    ("q" "Quote" entry
                     (file (lambda () (concat org-directory "quotes.org")))
                     "* %?")
                    ("e" "Emacs feature" entry
                     (file+headline (lambda () (concat org-directory "projects.org")) "Emacs features")
                     "* TODO %?")
                    ("p" "Project" entry
                     (file (lambda () (concat org-directory "projects.org")))
                     "* TODO %?")
                    ("l" "Log" entry
                     (file (lambda () (concat org-directory "log.org")))
                     "* %U\n%?")
                    ("r" "Book" entry
                     (file+headline (lambda () (concat org-directory "reading.org")) "Books")
                     "* TODO %?")
                    ("m" "Miscellaneous" entry
                     (file (lambda () (concat org-directory "misc.org")))
                     "* TODO %?" nil nil)
                    ("b" "Blog post ideas" entry
                     (file (lambda () (concat org-directory "blog.org")))
                     "* %? ")
                    ("w" "Websites" entry
                     (file+headline (lambda () (concat org-directory "reading.org")) "Websites")
                     "* %? ")))
  (setq org-capture-templates
                  '())
#+end_src

** Org Export/Publish
I have some custom functions that I use in the publishing process:

#+begin_src emacs-lisp
  (defun file-contents (filename)
    "Return the contents of FILENAME."
    (with-temp-buffer
      (insert-file-contents filename)
      (buffer-string)))

  (defun strings-to-regexp (&rest files)
    (rx-to-string (cons 'or files)))
#+end_src

Then, the code that I actually use to publish. This should really
belong with the data being published, as I noted in a blog post.

I use the ~org-export~ sitemap feature as a way of listing all of my
blog posts:

#+begin_src emacs-lisp
(defun org-publish-sitemap-function (title list)
  "Sitemap generation function."
  (concat "#+TITLE: Tanner Hoelzel\n"
          (file-contents "~/git/thoelze1.github.io/index-header.org")
          "* Blog\n"
          (org-list-to-org list)))

(defun org-publish-sitemap-format-entry (entry style project)
  (cond ((not (directory-name-p entry))
         (format "%s: [[file:%s][%s]]"
                 (format-time-string "%Y-%m-%d"
                                     (org-publish-find-date entry project))
                 entry
                 (org-publish-find-title entry project)))
        ((eq style 'tree)
         ;; Return only last subdir.
         (file-name-nondirectory (directory-file-name entry)))
        (t entry)))
#+end_src

#+begin_src emacs-lisp
  (setq org-twbs-head "
  <link  href=\"https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\">
  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\"></script>
  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js\"></script>
  ")
  ;; (setq org-twbs-preamble-format '(("en" "<p class=\"author\">%t</p>")))
  (setq org-export-with-toc 2)
  ;; https://miikanissi.com/blog/website-with-emacs.html
  ;; (setq website-header "~/git/thoelze1.github.io/org")
  (setq org-html-postamble-format '(("en" "<p>hi</p>")))
  (setq org-publish-project-alist
        '(("resume"
           :base-directory "~/git/resume"
           :publishing-directory "~/git/thoelze1.github.io"
           :base-extension nil
           :include ("resume.pdf")
           :publishing-function org-publish-attachment)
          ("content"
           :base-directory "~/git/thoelze1.github.io"
           :publishing-directory "~/git/thoelze1.github.io"
           :publishing-function org-html-publish-to-html
           :exclude "\\(?:index-header\\.org\\)" ;; (strings-to-regexp "index-header.org")
           :with-toc nil
           :html-postamble t
           :section-numbers nil
           :auto-sitemap t
           :sitemap-function org-publish-sitemap-function
           :sitemap-title "Tanner Hoelzel"
           :sitemap-filename "index.org"
           :sitemap-style list
           :sitemap-sort-files anti-chronologically
           :sitemap-format-entry org-publish-sitemap-format-entry)
          ("website" :components ("resume" "content"))))
#+end_src

** Org Attach
You can attach external files to org-roam nodes. They are stored in
the ~data~ subdirectory of your ~org~ directory.

** Org Roam
#+begin_src emacs-lisp
  (use-package org-roam)
  (setq org-roam-directory "~/Dropbox/org-roam")
  (org-roam-db-autosync-mode)
#+end_src
The org-roam-ui recommends installing via straight. This installed
another copy of org which broke my whole fucking emacs. Instead let's
not use straight (yet).

https://github.com/org-roam/org-roam-ui:

#+begin_src emacs-lisp
  (use-package org-roam-ui)
#+end_src
#+begin_src emacs-lisp :tangle no
  (use-package org-roam-ui
    :straight
    (:host github :repo "org-roam/org-roam-ui" :branch "main" :files ("*.el" "out"))
    :after org-roam
    ;;         normally we'd recommend hooking orui after org-roam, but since org-roam does not have
    ;;         a hookable mode anymore, you're advised to pick something yourself
    ;;         if you don't care about startup time, use
    ;;  :hook (after-init . org-roam-ui-mode)
    :config
    (setq org-roam-ui-sync-theme t
          org-roam-ui-follow t
          org-roam-ui-update-on-save t
          org-roam-ui-open-on-start t))
#+end_src

I use org-roam to help organize files. Sometimes a node might simply
represent an external files attached as an org-attachment.

*** Tagging
To be able to search by tags by default:
#+begin_src emacs-lisp
  (setq org-roam-node-display-template
        (concat "${title:*} "
                (propertize "${tags:10}" 'face 'org-tag)))
#+end_src
See https://github.com/org-roam/org-roam/pull/2054

*** Dailies
#+begin_src emacs-lisp :tangle no
  (setq )
  (setq org-roam-dailies-capture-templates
        '(("d" "default" entry "* %?" :target
           (file "~/git/thoelze1.github.io/org/sicp-exercises.org")
           "* %?")
          ("j" "Journal" entry
           (file (lambda () (concat org-directory "journal.org")))
           "* %U\n%?" :clock-in t :clock-resume t)
          ("q" "Quote" entry
           (file (lambda () (concat org-directory "quotes.org")))
           "* %?")
          ("e" "Emacs feature" entry
           (file+headline (lambda () (concat org-directory "projects.org")) "Emacs features")
           "* TODO %?")
          ("p" "Project" entry
           (file (lambda () (concat org-directory "projects.org")))
           "* TODO %?")
          ("l" "Log" entry
           (file (lambda () (concat org-directory "log.org")))
           "* %U\n%?")
          ("r" "Book" entry
           (file+headline (lambda () (concat org-directory "reading.org")) "Books")
           "* TODO %?")
          ("m" "Miscellaneous" entry
           (file (lambda () (concat org-directory "misc.org")))
           "* TODO %?" nil nil)
          ("b" "Blog post ideas" entry
           (file (lambda () (concat org-directory "blog.org")))
           "* %? ")
          ("w" "Websites" entry
           (file+headline (lambda () (concat org-directory "reading.org")) "Websites")
           "* %? ")))
#+end_src

** Org Agenda
Disclaimer: it seems that many things are difficult to do within ~org-agenda~:
- [[https://emacs.stackexchange.com/questions/31683/schedule-org-task-for-last-day-of-every-month][Repeating on the last day of each month]]
- [[https://emacs.stackexchange.com/questions/41446/org-mode-repeating-task-until][Repetition daily within a range]]
- [[https://karl-voit.at/2017/01/15/org-clone-subtree-with-time-shift/][Repeating on certain days of the week]]

Using the agenda allows scheduling future events, maintaining a todo
list, and logging tasks. Let's put it at hand:

#+begin_src emacs-lisp
(global-set-key (kbd "H-a") 'org-agenda-list)
(global-set-key (kbd "H-t") 'org-todo-list)
#+end_src

The agenda can be rebuild at any time ~org-agenda-redo~.

#+begin_src emacs-lisp
  (setq org-default-notes-file (concat org-directory "misc.org"))
  (setq org-agenda-files '("~/Dropbox/org-agenda/"))
  (setq org-agenda-start-on-weekday nil)
  (setq org-agenda-time-grid '((daily today require-timed)
                               (800 1000 1200 1400 1600 1800 2000)
                               "......" "----------..."))
#+end_src

I use tags to categorize items more than filenames:

#+begin_src emacs-lisp
  (setq org-agenda-prefix-format
        ' ((agenda . " %i %-12:c%?-12t% s")
           (todo . " %-8:T ")
           (tags . " %i %-12:c")
           (search . " %i %-12:c")))
#+end_src

Let's add some custom views:

#+begin_src emacs-lisp
(setq org-agenda-custom-commands
      '(("c" . "My Custom Agendas")
        ("cu" "Unscheduled TODO"
         ((todo ""
                ((org-agenda-overriding-header "\nUnscheduled TODO")
                 (org-agenda-skip-function '(org-agenda-skip-entry-if 'timestamp)))))
         nil
         nil)))
#+end_src

*** Scheduling events
Scheduling future events is accomplished simply by adding a timestamp
to an org entry. The schedule can then be viewed with ~org-agenda~.

Some tips for org "habits":
https://lists.gnu.org/archive/html/emacs-orgmode/2010-09/msg00406.html

#+begin_src emacs-lisp
(add-to-list 'org-modules 'org-habit)
#+end_src

*** Logging time
:LOGBOOK:
CLOCK: [2022-03-04 Fri 16:47]--[2022-03-04 Fri 16:48] =>  0:01
:END:
Logging tasks can be accomplished by clocking in and out with the
desired keybindings. You can view a log of your day at any time with
~org-agenda-log-mode~.

Clocking in and out is done a lot, so let's make those single
keystrokes:

#+begin_src emacs-lisp
(global-set-key (kbd "H-i") 'org-clock-in)
(global-set-key (kbd "H-o") 'org-clock-out)
#+end_src

I also like to add notes to tasks as I complete them:

#+begin_src emacs-lisp
  (setq org-log-note-clock-out 't)
#+end_src

You can see clock time with ~org-agenda-clockreport-mode~.

It is possible to clock out of a task by marking that task as
completed, but this doesn't prompt for a log note.

#+begin_src emacs-lisp
(setq org-clock-out-when-done t)
#+end_src

Searching for the item that you intend to clock into wastes time. By
using helm, we can improve the clocking interface:

#+begin_src emacs-lisp
  (defun my-org-clock-in (prefix)
    (interactive "P")
    ;;(message "%s" prefix)
    (if prefix
        (save-window-excursion
          (let ((original-buffer (current-buffer)))
            (helm-org-agenda-files-headings)
            (if (not (eq original-buffer (current-buffer)))
                (org-clock-in))))
      (org-clock-in)))

  (global-set-key (kbd "H-i") 'my-org-clock-in)
#+end_src

*** Managing TODOs
By default, TODOs have two states: TODO and DONE. We can use our own
states, with different state spaces for different types of tasks:

#+begin_src emacs-lisp
    (setq org-todo-keywords-tasks
          '(sequence "TODO(t!)" "|" "WAITING(w!)" "DONE(d!)" "CANCELED(c!)"))
    (setq org-todo-keywords-billing
          '(sequence "OWED(o)" "|" "BILLED(b!)" "PAID(p)"))
    (setq org-todo-keywords-inventory
          '(sequence "|" "OWNED" "LENT" "LOST" "WANTED"))
    (setq org-todo-keywords
          (list org-todo-keywords-tasks
                org-todo-keywords-billing
                org-todo-keywords-inventory))
#+end_src

The ~(!)~ after ~DONE~ is *required* for a note to be recorded when a
task moves into the ~DONE~ state. Let's hide state changes in the same
drawer that we clock time with:

#+begin_src emacs-lisp
  (setq org-log-into-drawer t)
#+end_src

~org-todo-keywords~ is made up of lists of lists: I can add a new list
of keywords if a new type of task corresponds to a different set of
states!

TODOs should have priority values so that the most important are
automatically brought to attention.

#+begin_src emacs-lisp
  (setq org-priority-highest 1)
  (setq org-priority-lowest 9)
  (setq org-priority-default 5)
#+end_src

Now, items shown from ~org-todo-list~ are sifted by priority value.

#+begin_src emacs-lisp
  (setq org-enforce-todo-dependencies t)
#+end_src

A problem: I have a recurring calendar item that I want to appear in
the agenda 

#+begin_src emacs-lisp
  (setq org-agenda-todo-ignore-scheduled t)
#+end_src

* Custom functions
#+begin_src emacs-lisp
  (global-set-key (kbd "s-<backspace>")
                  (lambda () (interactive) (if (= (current-column) 0)
                                   (backward-delete-char 1) (kill-line 0))))

  (defun copy-sexp ()
    (interactive)
    (save-window-excursion
      (save-excursion
        (avy-goto-char ?\()
        (mark-sexp)
        (kill-ring-save (point) (mark))
        (pop-mark)
        (pop-mark))))
  (global-set-key (kbd "C-c C-M-@") 'copy-sexp)
#+end_src

* MacOS Quirks
Not sure if this is still necessary?

#+begin_src emacs-lisp
  (add-hook 'emacs-startup-hook (lambda () (make-frame-visible)))
#+end_src

#+begin_src emacs-lisp
  (setq inferior-lisp-program "/opt/local/bin/sbcl")
#+end_src

* Environment variables
There are a few scenarios where emacs inherits a default set of
environment variables rather than the complete set you want it to:
- Launching Emacs as GUI app on OS X
- Launching Emacs as daemon from launchd or systemd

In such cases, we can use [[https://github.com/purcell/exec-path-from-shell][exec-path-from-shell]]. This loads environment
variables from your shell. Because of how shells work, it loads from
~.zshenv~ rather than ~.zshrc~. So for everything to work, you must
both put your environment variables in ~.zshenv~ and call
~exec-path-from-shell-initialize~:

Read this at some point:
https://blog.flowblok.id.au/2013-02/shell-startup-scripts.html

** Initializing Environment Variables
#+begin_src emacs-lisp
  (if (string-equal system-type "darwin")
      (when (memq window-system '(mac ns x))
        (exec-path-from-shell-initialize)));
#+end_src

** Updating Environment Variables
Use ~exec-path-from-shell-copy-env~

** Inspecting Environment Variables
Use ~getenv~

* Linux Quirks
This fixes som security issue on linux (forget the link), and an issue
on mac:
- https://emacs.stackexchange.com/questions/68288/error-retrieving-https-elpa-gnu-org-packages-archive-contents

#+begin_src emacs-lisp
  (setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3")
#+end_src

* GPG
#+begin_src emacs-lisp
  (require 'epa-file)
  (custom-set-variables '(epg-gpg-program  "/usr/local/bin/gpg"))
  (epa-file-enable)
#+end_src

* Text editing
#+begin_src emacs-lisp
  (defun my-open-line ()
    "My preferred behavior for open-line"
    (interactive)
    (save-excursion
      (default-indent-new-line 1)))
#+end_src
We cannot and should not do the following:
#+begin_src emacs-lisp :tangle no
  (defun open-line ()
    (interactive)
    (call-interactively my-open-line))
#+end_src
~magit~, for one, uses ~open-line~ and so we shouldn't change its behavior
* Syntax Highlighting
#+begin_src emacs-lisp
  (use-package osx-plist :pin melpa-stable)
#+end_src

* Breaking a long string literal into lines
** First Attempts
#+begin_src emacs-lisp
  (global-set-key (kbd "H-5") 'paredit-str-reindent)
  (global-set-key (kbd "H-6") (lambda ()
                                (interactive)
                                (message
                                 (number-to-string (line-length)))))

  (defun dec (x) (- x 1))

  (defun line-length ()
    (let ((eol-pos (save-excursion
                     (move-end-of-line nil)
                     (point)))
          (bol-pos (save-excursion
                     (move-beginning-of-line nil)
                     (point))))
      (- eol-pos bol-pos)))

  (let ((eol-pos (line-end-position)))
    (dec (if (= (line-number-at-pos) 1)
             eol-pos
           (- eol-pos (line-end-position 0)))))


  ""

  (defun paredit-sexp-multilinep ()
    (interactive)
    (save-excursion
      (paredit-backward-up)
      (let ((current-line (line-number-at-pos)))
        (paredit-forward)
        (not (= current-line (line-number-at-pos))))))


  (defun paredit-str-block-reindent ()
    (paredit-backward-up)
    (paredit-forward-down)
    (paredit-forward)
    (while (let ((curr (point)))
             (save-excursion
               (paredit-forward-up)
               (paredit-backward-down)
               (< (point) curr)))
      (paredit-forward)
      (paredit-join-sexps)
      ))
  (defun paredit-str-reindent ()
    (interactive)
    (paredit-backward-up)
    (paredit-open-round)
    (insert "str ")
    (paredit-forward-slurp-sexp)
    (forward-char)
    (paredit-reindent-defun)
    (while (paredit-sexp-multilinep)
      (move-end-of-line)
      (insert " ")
      (while (> (+ 1 (line-length)) fill-column)
        (backward-word))
      (paredit-split-sexp)
      (delete-char 1)
      (insert "\n")))

  (defun paredit-str-reindent ()
    (interactive)
    (paredit-backward-up)
    (paredit-open-round)
    (insert "str ")
    (paredit-forward-slurp-sexp)
    (forward-char)
    (clojure-fill-paragraph)
    (while (paredit-sexp-multilinep)
      (let (()))
      (move-end-of-line nil)
      (insert "__")
      (clojure-fill-paragraph)
      (paredit-backward-up)
      (forward-char)
      (delete-char 1)
      (move-end-of-line nil)
      (paredit-split-sexp)
      (delete-char 1)
      (insert "\n")
      (forward-char)
      (delete-horizontal-space)
      (delete-char 1)
      (delete-horizontal-space)
      (indent-for-tab-command)))
#+end_src
** A Functional Approach
#+begin_src emacs-lisp
  (defun region-to-string ()
    (buffer-substring-no-properties (region-beginning) (region-end)))

  (defun paredit-string-literal-to-string ()
    (if (paredit-in-string-p)
        (paredit-backward-up))
    (mark-sexp)
                                          ; (kill-region 0 0 t) ; BEG
                                          ; and END cannot be nil (this
                                          ; is a bug in emacs
                                          ; documentation)
                                          ; (current-kill 0 t)
    (let ((s (region-to-string)))
      (delete-region (region-beginning) (region-end))
      s))

  (defun paredit-break-str (str)
    (let* ((str (paredit-string-literal-to-string))
           (strs (break-string str)))
      (put-string-back-into-buffer strs)))

#+end_src
** Working library
#+begin_src emacs-lisp
  (defun line-length ()
      (let ((eol-pos (save-excursion
                       (move-end-of-line nil)
                       (point)))
            (bol-pos (save-excursion
                       (move-beginning-of-line nil)
                       (point))))
        (- eol-pos bol-pos)))

  (defun line-too-long-p ()
    (> (line-length) fill-column))

  (defun move-to-line-break ()
    ;; Move forward one "word"
    (re-search-forward " ")
    ;; If we're beyond fill-column, we'll split here. If not, we want to
    ;; split at the last word-delimiter (space) before fill-column.
    (if (< (current-column) (dec fill-column))
        (progn
          (move-to-column (dec fill-column))
          (re-search-backward " ")
          (forward-char))))

  (defun split-line ()
    (paredit-split-sexp)
    (delete-char 1)
    (insert "\n")
    (forward-char))

  (defun prev-sexp-string-p ()
    (save-excursion
      (paredit-backward)
      (forward-char)
      (paredit-in-string-p)))

  (defun next-sexp-string-p ()
    (save-excursion
      (paredit-forward)
      (paredit-forward)
      (prev-sexp-string-p)))

  (defun join-strs-around-point ()
    "Joins all adjacent string literals around point."
    (interactive)
    (if (paredit-in-string-p)
        (paredit-backward-up))
    ;; Move backward to first string literal
    (while (prev-sexp-string-p)
      (paredit-backward))
    ;; Now join all following strs
    (while (next-sexp-string-p)
      (paredit-forward)
      (paredit-join-sexps)
      (paredit-backward-up)))

  (defun paredit-fill-str ()
    "Break string-literal(s) around point into shorter components,
  maximizing line-width without exceeding fill-column. Similar to
  `fill-paragraph', but does not alter whitespace of string literal.

  Assumes that:
    - point is within or at start of a string literal
    - string literal already has the desired indentation
    - string literal does not contain tabs or newlines"
    (interactive)
    (join-strs-around-point)
    (forward-char)
    ;; Now we repeatedly split the string until it fits. There is still
    ;; an unhandled case where the final line is too long due to
    ;; characters following the string...
    (while (line-too-long-p)
      (move-to-line-break)
      (split-line)
      (indent-for-tab-command))
    ;; Move point to end of string
    (paredit-forward-up))
#+end_src
* Python
#+begin_src emacs-lisp
  (setq python-shell-interpreter "/Users/tannerhoelzel/shell3.sh")

  (setq python-shell-interpreter "python3")
(setq python-shell-interpreter-args "")
#+end_src
Now we can use ~C-c c-p~ to start a python REPL from a python buffer.

Sources:
- https://stackoverflow.com/questions/25669809/how-do-you-run-python-code-using-emacs#:~:text=Once%20you%20open%20your%20python,one%20containing%20the%20python%20file.
- https://emacs.stackexchange.com/questions/36463/specifying-python-version-in-run-python
* JavaScript
For the lsp-backend, I found that `m-x install-server` didn't work for
ts-ls. But this did:
#+begin_src bash
npm i -g typescript-language-server; npm i -g typescript
#+end_src

Also, the default JS mode uses its own function (~js-find-symbol~)
instead of xref! Hate that. Supposedly people like this other
mode:
#+begin_src emacs-lisp
  (use-package js2-mode
    :pin melpa-stable
    :mode "\\.js\\'")
  (setq js2-strict-missing-semi-warning nil)
  (define-key js2-mode-map (kbd "M-.") nil)
#+end_src

I should change that so that it doesn't trigger for react files. Also,
it might not offer much over js-mode, in which case I should consider
using js-mode for JS files and just remapping ~M-.~ to
~xref-find-definitions~.
** React
Check out this nice tutorial from lsp-mode:
https://emacs-lsp.github.io/lsp-mode/tutorials/reactjs-tutorial/

Remember that js2-mode doesn't support JSX and instead recommends
using Emacs' builtin js-mode
** Vue
*** Syntax Highlighting
I tried installing [[https://github.com/AdamNiederer/vue-mode][vue-mode]] according to the installation
instructions, but I kept running into an error (see [[https://github.com/dgutov/mmm-mode/issues/112][GitHub issue]]). I
was unable to resolve the issue and the project is unmaintained in
November 2022. I found [[https://github.com/AdamNiederer/vue-mode/issues/109][this issue]] where polymode is recommended over
vue-mode. In this issue I discovered that web-mode is an alternative
to vue-mode:
#+begin_src emacs-lisp
  (use-package web-mode
    :pin melpa-stable
    :mode "\\.vue\\'"
    :config
    (add-hook 'vue-mode-hook #'lsp))
#+end_src

*** Indentation
The project I'm working on doesn't use indentation in the ~<script>~
block of a ~.vue~ file. See
https://emacs.stackexchange.com/questions/30587/web-mode-uses-1-space-indent-instead-of-2:
#+begin_src emacs-lisp
  (setq web-mode-script-padding 0)
#+end_src

*** Jump to definition/declaration
We'll use ~lsp-mode~ for this. General instructions for lsp:
https://emacs-lsp.github.io/lsp-mode/page/installation/

**** Vetur (Vue2)
Instructions for Vue2 lsp support:
https://emacs-lsp.github.io/lsp-mode/page/lsp-vetur/
#+begin_src emacs-lisp :tangle no
  (use-package lsp-mode
    :pin melpa
    :straight nil)
#+end_src
We also need to install the server. I just did this manually:
#+begin_src bash
  npm install -g vls
#+end_src
We also could have used ~M-x lsp-install-server~. According to this
[[https://github.com/emacs-lsp/lsp-mode/issues/1380][issue]], you also have to install typescript:
#+begin_src bash
  npm install -g typescript
#+end_src

**** Volar (Vue3)
The ~vetur~ LSP implementation for Vue has been replaced by ~volar~,
but it is in the process of being merged into ~lsp-mode~ as of
November 2022 and I couldn't get it to work.
#+begin_src emacs-lisp :tangle no
  (straight-use-package
   '(lsp-volar :type git :host github :repo "jadestrong/lsp-volar"))
  (use-package lsp-volar
    :straight t)
  (straight-use-package
   '(lsp-mode :type git :host github :repo "emacs-lsp/lsp-mode"))
  (use-package lsp-mode
    :straight t)
  ;;(setq lsp-enabled-clients '(
#+end_src

* Shell
I don't like how the ~eshell~ prompt is editable:
#+begin_src emacs-lisp
  (setq comint-prompt-read-only t)
#+end_src
* Search
** File-wide
Helm-swoop is an improved searching interface:
#+begin_src emacs-lisp
  (use-package helm-swoop :pin melpa-stable)
  (global-set-key (kbd "M-i") 'helm-swoop)
  (setq helm-swoop-speed-or-color nil)
  (global-set-key (kbd "M-I") 'helm-swoop-back-to-last-point)
  (global-set-key (kbd "C-c M-i") 'helm-multi-swoop)
  (global-set-key (kbd "C-x M-i") 'helm-multi-swoop-all)

  ;; When doing isearch, hand the word over to helm-swoop
  (define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch)
  ;; From helm-swoop to helm-multi-swoop-all
  (define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop)

  ;; Instead of helm-multi-swoop-all, you can also use helm-multi-swoop-current-mode
  (define-key helm-swoop-map (kbd "M-m") 'helm-multi-swoop-current-mode-from-helm-swoop)

  ;; Move up and down like isearch
  (define-key helm-swoop-map (kbd "C-r") 'helm-previous-line)
  (define-key helm-swoop-map (kbd "C-s") 'helm-next-line)
  (define-key helm-multi-swoop-map (kbd "C-r") 'helm-previous-line)
  (define-key helm-multi-swoop-map (kbd "C-s") 'helm-next-line)

  ;; Save buffer when helm-multi-swoop-edit complete
  (setq helm-multi-swoop-edit-save t)

  ;; Split direcion. 'split-window-vertically or 'split-window-horizontally
  (setq helm-swoop-split-direction 'split-window-vertically)

  ;; If nil, you can slightly boost invoke speed in exchange for text color
  (setq helm-swoop-speed-or-color nil)

  ;; ;; Go to the opposite side of line from the end or beginning of line
  (setq helm-swoop-move-to-line-cycle t)

  ;; Optional face for line numbers
  ;; Face name is `helm-swoop-line-number-face`
  (setq helm-swoop-use-line-number-face t)

  ;; If you prefer fuzzy matching
  (setq helm-swoop-use-fuzzy-match t)
  #+end_src
** Directory-wide (grep)
There are so many good different tools for this! Deft, ripgrep, silver
searcher, consult, velocity. See here for feature comparison:
https://beyondgrep.com/feature-comparison/

Found some setting I like here:
https://endlessparentheses.com/exclude-directories-from-grep.html
#+begin_src emacs-lisp
  (add-to-list 'grep-find-ignored-directories "node_modules")
  (add-hook 'grep-mode-hook (lambda () (toggle-truncate-lines 1)))
#+end_src

But actually, code searching can be so much better than ~grep.el~!
With helm-projectile, it's a directory wide ~swoop~:
#+begin_src emacs-lisp
  (use-package helm-projectile :pin melpa-stable)
  (use-package helm-ag :pin melpa-stable)
  (use-package ag :pin melpa-stable)
#+end_src

* Window decoration (line numbers & /the fringe/)
Disclaimer: I'm still not sure I'll stick with line numbers. They take
up a lot of real estate. I've tried to mitigate this, e.g. by
narrowing the width with ~M-x customize-group display-line-numbers~ to
change to a more compact font.

The bottom line is that there needs to be a visual separation between
an application and the edge of the screen. The fringe is basically
useless--well, it indicates end-of-buffer and line-wrap, at least. But
line numbers yield that information and more while using just a little
more space. Plus, they help distinguish files where line numbers
matter from files where they don't.

I do like the column number too:
#+begin_src emacs-lisp
  (column-number-mode)
#+end_src

** Appearance
I'm going to leave some notes hear about customization that lives in
~./custom.el~
- I tried to use a compact font for line numbers, but it didn't
  work. It almost worked, but numbers of with different numbers of
  digits were centered differently, yielding a ~2px gap between 99 and
  100 e.g.
- Making the fringe, vertical border, and line number background the
  same color is handy

I've got to set up the fringe:
#+begin_src emacs-lisp
  (setq fringe-mode 4)
#+end_src

TODO: programatically set a buffer-local left fringe width depending
on whether line numbers are enabled or not (if line numbers are
enabled, there should be no left fringe).

Since I'm using line numbers, I don't need to see the
line-continuation glyph in the fringe:
#+begin_src emacs-lisp
  (add-to-list 'fringe-indicator-alist '(continuation . nil))
#+end_src
There's definitely a way to provide custom bitmaps, but my goal is not
to see those glyphs and so I don't need to spend time figuring out how
to do that.

And this improves the color of the vertical border (should probably
be edited to pull from zenburn):
#+begin_src emacs-lisp
  (set-face-foreground 'vertical-border "#383838")
#+end_src

Unresolved questions:
- Why did the compact font not work? Is that a bug or expected
  behavior?
- Why in some buffers is extra space added before the line number?
- Why doesn't dynamic width for line numbers work?

** Line Numbers
*** Blacklist model                                              :noexport:

The thinking with a blacklist model is that I want line numbers when
working with pretty much any text file, some of which have no standard
extension (.env, .old, .local, etc). So we enable globally:

#+begin_src emacs-lisp
  (global-display-line-numbers-mode)
#+end_src

This affects all modes except some those that turn them off by
default, like magit:
https://github.com/magit/magit/commit/c19d8bb4f7d436ff7654be57601703ef517d6d4d

But some other modes shouldn't have line numbers either, like
~dired~. Luckily, we can use ~display-line-numbers--turn-on~ to
customize which buffers ~global-display-line-numbers-mode~ affect:
#+begin_src emacs-lisp
  (defvar display-line-numbers--exempt-modes
    '(vterm-mode
      eshell-mode
      shell-mode
      term-mode
      ansi-term-mode
      dired-mode))

  (defun display-line-numbers--turn-on ()
    "Turn on line numbers except for certain major modes.
  Exempt major modes are defined in `display-line-numbers--exempt-modes'."
    (unless (or (minibufferp)
                (member major-mode display-line-numbers--exempt-modes))
      (display-line-numbers-mode)))
#+end_src
I got this from https://www.emacswiki.org/emacs/LineNumbers.

If ~display-line-numbers--turn-on~ weren't available, we could use
this instead:

#+begin_src emacs-lisp :exports none
  (add-hook 'dired-mode-hook (lambda () (display-line-numbers-mode 0)) 100)
#+end_src

Which uses the optional ~depth~ parameter of ~add-hook~
(https://www.gnu.org/software/emacs/manual/html_node/elisp/Setting-Hooks.html).
feels hacky though.

Still, there are modes that it is more difficult to turn them off
for.

Unfortunately, I was never able to turn off line numbers in helm or
customize, so I use the following whitelist model:

*** Whitelist model
#+begin_src emacs-lisp
  (add-hook 'prog-mode-hook 'display-line-numbers-mode)
  (add-hook 'fundamental-mode-hook 'display-line-numbers-mode)
  (add-hook 'text-mode-hook 'display-line-numbers-mode)
#+end_src

* Tabs
Also centaur-tabs
#+begin_src emacs-lisp
  (use-package centaur-tabs :pin melpa-stable)
#+end_src
* Neotree
https://emacs.stackexchange.com/questions/31660/how-can-i-set-neotree-to-always-show-hidden-files
#+begin_src emacs-lisp
  (use-package neotree :pin melpa-stable)
  (setq neo-theme 'ascii)
  (setq-default neo-show-hidden-files t)
#+end_src
By default, it constantly automatically switches root to the current
file's directory. Fix:
#+begin_src emacs-lisp
  (setq neo-autorefresh nil)
#+end_src
#+begin_src emacs-lisp
  (use-package treemacs :pin melpa-stable)
#+end_src
* Word wrapping
see ~toggle-truncate-lines~
* Pair programming: floobits
#+begin_src emacs-lisp
  (use-package floobits :pin melpa-stable)
#+end_src
Then make an account, update your ~/.floorc.json. Then:
- ~floobits-share-dir-public~ to share a project
- ~floobits-add-to-workspace~ to add more files
** flootty
You can also install flootty:
#+begin_src bash
  pip install Flootty
  flootty --create --url=https://floobits.com/owner/workspace
#+end_src

You can trivially use ~term~, ~eshell~, or ~shell~ to run flootty. But
it would be cool if we could somehow connect to flootty with
emacs. The "right" way to do this feels like using flootty to run a
python repl as daemon, and then connect to it somehow with
~run-python~. The way I have it working is:
1. Write ~flootty.sh~:
   #+begin_src bash
     #!/bin/bash
     /usr/local/bin/flootty --create --url=https://floobits.com/tanner/interviews --shell=/path/to/python.sh
   #+end_src
2. Write ~python.sh~:
   #+begin_src bash
     #!/bin/bash
     python3
   #+end_src
3. Set up emacs:
   #+begin_src emacs-lisp
     (setq python-shell-interpreter "python3") ;;"/path/to/flootty.sh")
   #+end_src

There's something wrong but it sort of works
* Popups
When using functions that call ~compile~, the function
~compilation-ask-about-save~ triggers a prompt to save buffer for each
saved edited buffer. Often this causes a frustrating situation where
the prompt is immediately hidden by another "reverting ..." message,
preventing you from editing the command until you enter another
(invalid) keystroke which rings the bell.
#+begin_src emacs-lisp
  (setq compilation-ask-about-save nil)
#+end_src
* dotenv
#+begin_src emacs-lisp
  (use-package dotenv-mode :pin melpa-stable)
  (add-to-list 'auto-mode-alist '("\\.env\\..*\\'" . dotenv-mode))
#+end_src
* Code formatting html
Can be delegated to LSP mode. Remember:
- ~auto-fill-mode~ for hitting enter at end of line to indent (and get
  different results than with ~fill-region~
- ~sgml-pretty-print~, does something but also fucks stuff up
- lsp-mode fucks up a lot
#+begin_src emacs-lisp
  (use-package prettier-js :pin melpa)
#+end_src
https://stackoverflow.com/questions/71007796/prettier-break-html-classes-in-multiple-lines
https://github.com/prettier/prettier/issues/10918
The bottom line here is that you shouldn't be writing HTML by hand in
the first place. We also shouldn't have languages with insane syntax. 
Compare the clojure style guide with the vue style guide:
https://vuejs.org/style-guide/rules-essential.html#use-detailed-prop-definitions

Future-proofing and fault. When committing these new files to the
tradigro frontend repo, I have gone to great lengths to try to
"future-proof" them so that people in the future can't go "oh ffs what
was this guy thinking, this was a horrible design choice." In this
case future proofing means choosing the right style now, because it's
hard to change this later: do you do it all at once, as people commit
(it's also error prone). I have this desire for revertability in other
places: purely functional package management, and certainly outside of
software too. Importantly, my desire to future-proof goes hand in hand
with my anger towards others about poor design decisions. I place
great responsibility in the hands of the creator which puts great
pressure on me when I am in that role, and justifies great frustration
when other people are in that role. Why do I pick both? If the two go
hand-in-hand, why not just pick less of each? (Less) responsiblity,
(less) frustration, (less) pressure.

Dear god look at this syntax: https://v2.vuejs.org/v2/guide/class-and-style.html

* Denote
#+begin_src emacs-lisp
  (straight-use-package 'denote)
#+end_src
