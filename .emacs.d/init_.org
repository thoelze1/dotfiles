#+TITLE: Tanner's Emacs Config

This file gets loaded from [[file:init.el][~init.el~]] and configures emacs to my liking
across a variety of systems.

When your init file is non-literate, you are forced to separate your
configuration into multiple files, adding complexity. With literate
org, you are able to organize and even do away with the overhead of
additional org keywords (~#+begin_src~, etc) by using formatting, such
as colored code blocks!

* Startup
It is possible to declare the initial buffer with
~initial-buffer-choice~.

#+begin_src emacs-lisp
  (setq inhibit-splash-screen t)
#+end_src

* Package management
There are several ways to manage emacs packages, both within and
without emacs.
** Within Emacs
Emacs has a built-in package manager, ~package.el~. By default, its
sole repository is GNU's [[https://elpa.gnu.org][ELPA]] (Emacs Lisp Package Archive), but we can
just add some of our own:

#+begin_src emacs-lisp
  (require 'package)
  (add-to-list 'package-archives '("melpa-stable" . "http://stable.melpa.org/packages/") t)
  (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t)
#+end_src

At this point, we can select packages for installation using the
~package-selected-packages~ variable, install those packages with
~package-install-selected-packages~, and load them with
~package-initialize~. Then, packages can be used right away just by
using them, or by explicitly using ~require~:

#+begin_src emacs-lisp :exports none
  (setq package-selected-packages
        '(org-roam
          minibuffer-line
          fancy-battery
          xelb
          haskell-mode
          geiser
          ox-twbs
          yasnippet
          exwm
          htmlize
          org-babel-eval-in-repl
          paredit
          zenburn-theme
          avy
          slime
          sicp
          multiple-cursors
          exec-path-from-shell
          magit))
  (package-install-selected-packages)
  (package-initialize)
#+end_src

Doing this, however, separates the package installation,
loading, and configuration which defeats encapsulation and
scales poorly across machines. Instead, we can use ~use-package~:

#+begin_src emacs-lisp
  (when (not (package-installed-p 'use-package))
    (package-refresh-contents)
    (package-install 'use-package))
#+end_src

Now, ~use-package~ loads packages for use! In fact, ~use-package~ can
abstract not only package loading, but also package installation:

#+begin_src emacs-lisp
  (require 'use-package-ensure)
  (setq use-package-always-ensure t)
#+end_src

** Within Guix
I don't yet have a good reason to manage my Emacs packages in
Guix. Managing packages within Emacs has the benefit of simplicity and
portability, so I'll continue managing packages in Emacs until there's
a good reason not to.

** Local Elisp
Any local 
#+begin_src emacs-lisp
  ; Local packages
  ;; Tell emacs where other config files are
  (setq site-lisp-dir
        (expand-file-name "site-lisp" user-emacs-directory))
  (add-to-list 'load-path site-lisp-dir)
  ;; Add local projects to load path
  (dolist (project (directory-files site-lisp-dir t "\\w+"))
    (when (file-directory-p project)
      (add-to-list 'load-path project)))
  (require 'spotify)
  (require 'vimgolf)
#+end_src

* Customization

* Debugging
#+begin_src emacs-lisp
  (setq debug-on-error t)
#+end_src

* Dired
#+begin_src emacs-lisp
  (add-hook 'dired-mode-hook 'auto-revert-mode)
#+end_src

* Paredit
#+begin_src emacs-lisp
  (add-hook 'scheme-mode-hook #'enable-paredit-mode)
  (add-hook 'emacs-lisp-mode-hook #'enable-paredit-mode)
#+end_src

* Yasnippet
#+begin_src emacs-lisp
(use-package yasnippet)
  (setq yas-snippet-dirs '("~/.emacs.d/snippets"))
  (add-hook 'scheme-mode-hook #'yas-minor-mode)
  (yas-reload-all)
#+end_src

* Helm
#+begin_src emacs-lisp
  (use-package helm)
  (global-set-key (kbd "M-x") #'helm-M-x)
  (global-set-key (kbd "C-x r b") #'helm-filtered-bookmarks)
  (global-set-key (kbd "C-x C-f") #'helm-find-files)
(global-set-key (kbd "C-x b") #'helm-buffers-list)
  (helm-mode 1)
#+end_src

* Geiser

* Desktop Environment
#+begin_src emacs-lisp
  (setq-default mode-line-format nil)

  (setq temp-max 25000)
  (setq temp-min 1000)
  (setq temp-default 2500)
  (setq temp-step 100)
  (setq temp temp-default)

  (setq brightness-default 0.5)
  (setq brightness brightness-default)
  (setq brightness-step 0.05)
  (setq brightness-max 1.0)
  (setq brightness-min 0.1)

  (defun temp-string () (format "%dK" temp))

  (defun redshift-update ()
    (start-process "" nil "redshift" "-P"
                   "-O" (temp-string)
                   "-b" (number-to-string brightness)))

  ;; What's a more lispy way of doing these redshift increment/decrement
  ;; functions? A HOF that does a "bounded-add"? 
  (defun temp-increment ()
    (interactive)
    (setq temp (min (+ temp temp-step)
                    temp-max))
    (redshift-update)
    (minibuffer-line--update))

  (defun temp-decrement ()
    (interactive)
    (setq temp (max (- temp temp-step)
                    temp-min))
    (redshift-update)
    (minibuffer-line--update))

  (defun brightness-increment ()
    (interactive)
    (setq brightness (min (+ brightness brightness-step)
                          brightness-max))
    (redshift-update)
    (minibuffer-line--update))

  (defun brightness-decrement ()
    (interactive)
    (setq brightness (max (- brightness brightness-step)
                          brightness-min))
    (redshift-update)
    (minibuffer-line--update))
  (setq minibuffer-line-refresh-interval 1)

  (setq minibuffer-line-format
          '(" "
           (:eval
            (format-time-string "%m/%d/%Y %T"))
           " | ðŸ”‹ "
           (:eval
            (battery-format "%p" (funcall battery-status-function)))
           "%% | "
           (:eval
            (format "%.2d" (* brightness 100)))
           "%% | "
           (:eval (temp-string))
           " | "
           ))

  (setq mode-line-format nil)
  #+end_src

* Appearance
If these are put in early-init.el then the frame briefly appears as
less than full screen, then expands (when starting with
emacsclient, at least). if started with emacs, then the frame stays
invisible.

#+begin_src emacs-lisp :tangle no
  (add-to-list 'initial-frame-alist '(visibility . nil))
  (add-to-list 'default-frame-alist '(fullscreen . maximized))
#+end_src

#+begin_src emacs-lisp
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (if (string-equal system-type "darwin")
      (progn
        (add-to-list 'default-frame-alist '(font . "SF Mono-12"))
        (add-to-list 'default-frame-alist '(undecorated . t))
        (add-to-list 'default-frame-alist '(fullscreen . maximized))))
  ;; set transparency
  ;; https://lwn.net/Articles/88179/
  ;; first value is for active frame, second value is for inactive frame
  ;; (set-frame-parameter (selected-frame) 'alpha '(99 100))
  (setq ring-bell-function 'ignore)
#+end_src

* Avy
See https://github.com/abo-abo/avy/wiki/defcustom.

#+begin_src emacs-lisp
  (setq avy-keys '(?f ?j ?d ?k ?s ?l ?a ?\; ?' ?v ?n ?c ?m ?x ?, ?z
                   ?. ?b ?/ ?t ?u ?r ?i ?e ?o ?w ?p ?q ?\[ ?5 ?7 ?4
                   ?8 ?3 ?9 ?2 ?0 ?1 ?- ?6 ?= ?\] ?\\ ?` ?F ?J ?D ?K
                   ?S ?L ?A ?: ?\" ?V ?N ?C ?M ?X ?< ?Z ?> ?B ?? ?T
                   ?U ?R ?I ?E ?O ?W ?P ?Q ?{ ?% ?& ?$ ?* ?# ?\( ?@
                   ?\) ?! ?_ ?^ ?+ ?} ?| ?~))
  (setq avy-case-fold-search nil)
  (global-set-key (kbd "H-a") 'avy-goto-char)
#+end_src

* Tabs and spaces
#+begin_src emacs-lisp
    (setq-default c-basic-offset 4)
    (setq-default indent-tabs-mode nil)
    (setq-default indicate-empty-lines t)
#+end_src

* Enable functions
#+begin_src emacs-lisp
  (put 'narrow-to-region 'disabled nil)
  (put 'upcase-region 'disabled nil)
#+end_src

* Auto-generated files
Emacs generates (sometimes) helpful files, but litters them across the
filesystem by default. Let's keep them all in one place.

** Backups and  autosaves
Emacs uses "autosaves" and "backups" to prevent unintended loss of
work. An autosave periodically saves the buffer of an open file, so
that work not-yet-written to the filesystem is retained in the event
that emac crashes. A backup is a copy of a file that you have written
to, from emacs, that ensures you retain the original file in the event
of an accidental file overwrite. We definitely want to keep both these
features, but we want to store all of the autosaves and backups in one
place so that they don't clutter up the filesystem:

#+begin_src emacs-lisp
  (setq backup-directory-alist `(("." . "~/.emacs.d/.backups"))
        auto-save-file-name-transforms `((".*", "~/.emacs.d/.autosaves/\\1" t)))
  (setq desktop-path '("~/.emacs.d/desktop"))
#+end_src

** ~customize~

#+begin_src emacs-lisp
  (setq custom-file (concat user-emacs-directory "/custom.el"))
#+end_src
* Keyboard Setup

** Hyper
Once we add the ~hyper~ modifier Note how many bindings we can have
for number keys! First, we have 10 number keys and 10 numbered
function keys. We then have 5 modifiers (control, shit, meta, super,
hyper) which can be chorded, and then for the function-number keys
(f1, f2 etc) we have 4 modifiers! Supposing we can reasonably use 3
modifiers with a keypress, that's 1 + 5 + 10 + 10 = 26 ways of
pressing a number key, and 1 + 5 + 10 = 15 ways of pressing a numbered
function key for a total of 26 + 15 = 41 ways of pressing a generic
"number" key. Insane!

*** MacOS
I have karabiner map space to fn globally. I then have emacs map fn to
hyper. However, OSX translates some keychords containing fn into
keychords without the fn key. I know of two such cases: fn+f3
translates to f3 (as do the other numbered fn keys) and fn+<left>
translates to <home> (the other arrows keys have similar
translations). Therefore, some of the keybindings below use the the
translation from OSX instead of a chord with H (<home> instead of
<H-left>, for example)

#+begin_src emacs-lisp
  (if (string-equal system-type "darwin")
      (setq ns-function-modifier 'hyper))
#+end_src

*** GNU/Linux
#+begin_src emacs-lisp
  (if (string-equal system-type "gnu/linux")
      (setq ns-right-control-modifier 'hyper))
#+end_src

** ASCII Redundancies
Since we're *never* (hopefully) in a TTY, we want to free up control
codes that correspond to characters that already exist on the
keyboard. Maybe one day when I switch to a 40% I'll go back on this,
but for now it would be cool to free up these keybindings.

But actually, it turns out doing so is a [[https://emacs.stackexchange.com/a/52334][huge fucking rabbit hole]], and
so I won't (dare to) proceed until I have reason to. 

* Buffers
#+begin_src emacs-lisp
  (global-set-key (kbd "s-k") 'kill-this-buffer)
#+end_src

** Windows
#+begin_src emacs-lisp
  (global-set-key (kbd "s-0") 'delete-window)
  (global-set-key (kbd "s-1") 'delete-other-windows)
  (global-set-key (kbd "s-2") 'split-window-below)
  (global-set-key (kbd "s-3") 'split-window-right)
  (global-set-key (kbd "H-g") 'magit-status)
  (global-set-key (kbd "<S-f3>") 'kmacro-end-macro)
  (global-set-key (kbd "H-c") 'mc/edit-lines)
  (global-set-key (kbd "s-f") 'make-frame)
  (global-set-key (kbd "s-n") 'other-window)
  (defun prev-window ()
    (interactive)
    (other-window -1))
  (global-set-key (kbd "s-p") 'prev-window)
  (global-set-key (kbd "s-o") 'find-file)
  (global-set-key (kbd "s-[") 'previous-buffer)
  (global-set-key (kbd "s-]") 'next-buffer)
  (defun next-window-next-buffer ()
    (interactive)
    (other-window 1)
    (next-buffer)
    (prev-window))
  (defun next-window-prev-buffer ()
    (interactive)
    (other-window 1)
    (previous-buffer)
    (prev-window))
  (global-set-key (kbd "s-{") 'next-window-prev-buffer)
  (global-set-key (kbd "s-}") 'next-window-next-buffer)
#+end_src

The =s=-={= and =s=-=}= bindings don't work due to my macbook keyboard
rollover, but these do:

#+begin_src emacs-lisp
  (global-set-key (kbd "<C-s-268632091>") 'next-window-prev-buffer)
  (global-set-key (kbd "<C-s-268632093>") 'next-window-next-buffer)
#+end_src

*** EXWM
#+begin_src emacs-lisp
  (if (string-equal system-type "gnu/linux")
      (progn
        ;;(require 'exwm-systemtray)
        ;;(exwm-systemtray-enable)
        ;;(setq exwm-systemtray-height 16)
        (require 'exwm)
        (require 'exwm-config)
        (exwm-config-default)
        (exwm-enable)
        ;;(setq fancy-battery-show-percentage t)
        ;;(fancy-battery-mode)
        (exwm-input-set-key (kbd "<XF86MonBrightnessDown>")
                      (lambda ()
                        (interactive)
                        (shell-command "light -U 5; light")))
        (exwm-input-set-key (kbd "<XF86MonBrightnessUp>")
                      (lambda ()
                        (interactive)
                        (shell-command "light -A 5; light")))      
        (exwm-input-set-key (kbd "<XF86MonBrightnessDown>") 'brightness-decrement)
        (exwm-input-set-key (kbd "<XF86MonBrightnessUp>") 'brightness-increment)
        (exwm-input-set-key (kbd "<S-XF86MonBrightnessDown>") 'temp-decrement)
        (exwm-input-set-key (kbd "<S-XF86MonBrightnessUp>") 'temp-increment)))
#+end_src

* Org
First some org-wide defaults.

#+begin_src emacs-lisp
  (setq org-directory "~/git/org/")
  (add-hook 'org-mode-hook 'turn-on-auto-fill)
  (add-hook 'org-mode-hook 'org-indent-mode) ; does this toggle?
  (setq org-src-tab-acts-natively t) ;; Src block indentation was horrible
  (setq org-src-window-setup 'current-window)
  (setq org-refile-targets '((org-agenda-files :maxlevel . 4)))
  (setq org-refile-use-outline-path nil)
  (org-babel-do-load-languages
   'org-babel-load-languages '((scheme . t)))
  (setq org-list-allow-alphabetical t)
#+end_src

Add org-entities. See https://emacs.stackexchange.com/questions/36898/proper-way-to-add-to-org-entities-user
#+begin_src emacs-lisp
  (setq org-entities-user
        '(("apple" "\\cmdkey" nil "&#8984;" "<kbd>COMMAND</kbd>" "<kbd>COMMAND</kbd>" "âŒ˜")))
  ;; https://emacs.stackexchange.com/questions/7323/how-to-add-new-markup-to-org-mode-html-export
  (setq org-html-text-markup-alist '((code . "<kbd>%s</kbd>")))
#+end_src

Display keyboard input properly in html: https://emacs.stackexchange.com/questions/7323/how-to-add-new-markup-to-org-mode-html-export
#+begin_src emacs-lisp
  (setq org-html-text-markup-alist '((code . "<kbd>%s</kbd>")))
#+end_src

Let's organize headings with tags:
#+begin_src emacs-lisp
  (setq org-tag-alist
        '(("emacs" . ?e)
          ("finance" . ?f)
          ("social" . ?s)
          ("chore" . ?c)))
#+end_src

#+begin_src emacs-lisp :tangle no
(use-package org-contrib)
(require 'ol-git-link)
#+end_src

#+begin_src emacs-lisp :tangle no
  (defun org-back-to-indentation ()
      "Move to start of text on current line"
      (interactive)
      (if (org-at-heading-p)
          (let ()
            (beginning-of-line)
            (re-search-forward (concat "^\\(?:" outline-regexp "\\)")p
                               nil t))
        (back-to-indentation)))
#+end_src

** Keybindings
Some good keybindings:
- =C=-=c= ='= for ~org-edit-special~

#+begin_src emacs-lisp
(add-hook 'org-mode-hook
            (lambda ()
              (local-set-key (kbd "<C-M-return>") 'org-insert-subheading)))
  (add-hook 'org-mode-hook
            (lambda ()
              (local-set-key (kbd "M-m") 'org-back-to-indentation)))
  (global-set-key (kbd "H-c") 'org-capture)
  (global-set-key (kbd "C-c c") 'org-capture)
  (global-set-key (kbd "C-c r") 'org-refile)
  (global-set-key (kbd "C-c a") 'org-agenda)
#+end_src

** Org Capture
#+begin_src emacs-lisp
  (setq org-capture-templates
                '(("s" "SICP Exercise" entry
                   (file "~/git/thoelze1.github.io/org/sicp-exercises.org")
                   "* %?")
                  ("j" "Journal" entry
                   (file (lambda () (concat org-directory "journal.org")))
                   "* %U\n%?")
                  ("q" "Quote" entry
                   (file (lambda () (concat org-directory "quotes.org")))
                   "* %?")
                  ("e" "Emacs feature" entry
                   (file+headline (lambda () (concat org-directory "projects.org")) "Emacs features")
                   "* TODO %?")
                  ("p" "Project" entry
                   (file (lambda () (concat org-directory "projects.org")))
                   "* TODO %?")
                  ("l" "Log" entry
                   (file (lambda () (concat org-directory "log.org")))
                   "* %U\n%?")
                  ("r" "Book" entry
                   (file+headline (lambda () (concat org-directory "reading.org")) "Books")
                   "* TODO %?")
                  ("m" "Miscellaneous" entry
                   (file (lambda () (concat org-directory "misc.org")))
                   "* TODO %?" nil nil)
                  ("b" "Blog post ideas" entry
                   (file (lambda () (concat org-directory "blog.org")))
                   "* %? ")
                  ("w" "Websites" entry
                   (file+headline (lambda () (concat org-directory "reading.org")) "Websites")
                   "* %? ")))
#+end_src

** Org Export/Publish
I have some custom functions that I use in the publishing process:

#+begin_src emacs-lisp
  (defun file-contents (filename)
    "Return the contents of FILENAME."
    (with-temp-buffer
      (insert-file-contents filename)
      (buffer-string)))

  (defun strings-to-regexp (&rest files)
    (rx-to-string (cons 'or files)))
#+end_src

Then, the code that I actually use to publish. This should really
belong with the data being published, as I noted in a blog post.

I use the ~org-export~ sitemap feature as a way of listing all of my
blog posts:

#+begin_src emacs-lisp
(defun org-publish-sitemap-function (title list)
  "Sitemap generation function."
  (concat "#+TITLE: Tanner Hoelzel\n"
          (file-contents "~/git/thoelze1.github.io/index-header.org")
          "* Blog\n"
          (org-list-to-org list)))

(defun org-publish-sitemap-format-entry (entry style project)
  (cond ((not (directory-name-p entry))
         (format "%s: [[file:%s][%s]]"
                 (format-time-string "%Y-%m-%d"
                                     (org-publish-find-date entry project))
                 entry
                 (org-publish-find-title entry project)))
        ((eq style 'tree)
         ;; Return only last subdir.
         (file-name-nondirectory (directory-file-name entry)))
        (t entry)))
#+end_src

#+begin_src emacs-lisp
  (setq org-twbs-head "
  <link  href=\"https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\">
  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\"></script>
  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js\"></script>
  ")
  ;; (setq org-twbs-preamble-format '(("en" "<p class=\"author\">%t</p>")))
  (setq org-export-with-toc 2)
  ;; https://miikanissi.com/blog/website-with-emacs.html
  ;; (setq website-header "~/git/thoelze1.github.io/org")
  (setq org-publish-project-alist
        '(("resume"
           :base-directory "~/git/resume"
           :publishing-directory "~/git/thoelze1.github.io"
           :base-extension nil
           :include ("resume.pdf")
           :publishing-function org-publish-attachment)
          ("content"
           :base-directory "~/git/thoelze1.github.io"
           :publishing-directory "~/git/thoelze1.github.io"
           :publishing-function org-html-publish-to-html
           :exclude "\\(?:index-header\\.org\\)" ;; (strings-to-regexp "index-header.org")
           :with-toc nil
           :html-postamble nil
           :section-numbers nil
           :auto-sitemap t
           :sitemap-function org-publish-sitemap-function
           :sitemap-title "Tanner Hoelzel"
           :sitemap-filename "index.org"
           :sitemap-style list
           :sitemap-sort-files anti-chronologically
           :sitemap-format-entry org-publish-sitemap-format-entry)
          ("website" :components ("resume" "content"))))
#+end_src

** Org Roam
#+begin_src emacs-lisp
  (setq org-roam-directory "~/Dropbox/org-roam")
#+end_src

** Org Agenda
Using the agenda allows scheduling future events, maintaining a todo
list, and logging tasks. Let's put it at hand:

#+begin_src emacs-lisp
(global-set-key (kbd "H-a") 'org-agenda-list)
(global-set-key (kbd "H-t") 'org-todo-list)
#+end_src

The agenda can be rebuild at any time ~org-agenda-redo~.

#+begin_src emacs-lisp
  (setq org-default-notes-file (concat org-directory "misc.org"))
  (setq org-agenda-files '("~/Dropbox/org-agenda/"))
#+end_src

*** Scheduling events
Scheduling future events is accomplished simply by adding a timestamp
to an org entry. The schedule can then be viewed with ~org-agenda~.

*** Logging time
Logging tasks can be accomplished by clocking in and out with the
desired keybindings. You can view a log of your day at any time with
~org-agenda-log-mode~.

Clocking in and out is done a lot, so let's make those single
keystrokes:

#+begin_src emacs-lisp
(global-set-key (kbd "H-i") 'org-clock-in)
(global-set-key (kbd "H-o") 'org-clock-out)
#+end_src

I also like to add notes to tasks as I complete them:

#+begin_src emacs-lisp
  (setq org-log-note-clock-out 't)
#+end_src

You can see clock time with ~org-agenda-clockreport-mode~.

It is possible to clock out of a task by marking that task as
completed, but this doesn't prompt for a log note.

#+begin_src emacs-lisp
(setq org-clock-out-when-done t)
#+end_src

*** Managing TODOs
By default, TODOs have two states: TODO and DONE. We can use our own
states, with different state spaces for different types of tasks:

#+begin_src emacs-lisp
  (setq org-todo-keywords-tasks
        '(sequence "TODO(t)" "|" "WAITING(w)" "DONE(d!)" "CANCELED(c)"))
  (setq org-todo-keywords-billing
        '(sequence "OWED(o)" "|" "BILLED(b!)" "PAID(p)"))
  (setq org-todo-keywords
        (list org-todo-keywords-tasks
              org-todo-keywords-billing))
#+end_src

The ~(!)~ after ~DONE~ is *required* for a note to be recorded when a
task moves into the ~DONE~ state. Let's hide state changes in the same
drawer that we clock time with:

#+begin_src emacs-lisp
  (setq org-log-into-drawer t)
#+end_src

~org-todo-keywords~ is made up of lists of lists: I can add a new list
of keywords if a new type of task corresponds to a different set of
states!

TODOs should have priority values so that the most important are
automatically brought to attention.

#+begin_src emacs-lisp
  (setq org-priority-highest 1)
  (setq org-priority-lowest 9)
  (setq org-priority-default 5)
#+end_src

Now, items shown from ~org-todo-list~ are sifted by priority value.

* Custom functions
#+begin_src emacs-lisp
  (global-set-key (kbd "s-<backspace>")
                  (lambda () (interactive) (if (= (current-column) 0)
                                   (backward-delete-char 1) (kill-line 0))))

  (defun copy-sexp ()
    (interactive)
    (save-window-excursion
      (save-excursion
        (avy-goto-char ?\()
        (mark-sexp)
        (kill-ring-save (point) (mark))
        (pop-mark)
        (pop-mark))))
  (global-set-key (kbd "C-c C-M-@") 'copy-sexp)
#+end_src

* MacOS Quirks
Not sure if this is still necessary?

#+begin_src emacs-lisp
  (add-hook 'emacs-startup-hook (lambda () (make-frame-visible)))
#+end_src

Reread these and fix zsh/shell stuff:
- https://github.com/purcell/exec-path-from-shell
- https://blog.flowblok.id.au/2013-02/shell-startup-scripts.html

#+begin_src emacs-lisp
  (if (string-equal system-type "darwin")
      (when (memq window-system '(mac ns x))
        (exec-path-from-shell-initialize)));
#+end_src

#+begin_src emacs-lisp
  (setq inferior-lisp-program "/opt/local/bin/sbcl")
#+end_src

* Linux Quirks
This fixes som security issue:

#+begin_src emacs-lisp
    (if (string-equal system-type "gnu/linux")
        (setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3"))
#+end_src
