#+TITLE: Tanner's Emacs Config
#+STARTUP: fold
#+PROPERTY: header-args :results none

This file gets loaded from [[file:init.el][~init.el~]] and configures emacs to my liking
across a variety of systems.

When your init file is non-literate, you are forced to separate your
configuration into multiple files, adding complexity. With literate
org, you are able to organize and even do away with the overhead of
additional org keywords (~#+begin_src~, etc) by using formatting, such
as colored code blocks!

* Generic routines
#+begin_src emacs-lisp
  (defun set-to-original (var)
    (set var (eval (car (get var 'standard-value)))))
#+end_src
* Startup
It is possible to declare the initial buffer with
~initial-buffer-choice~.

#+begin_src emacs-lisp
  (setq inhibit-splash-screen t)
#+end_src

* Package management
There are several ways to manage emacs packages, both within and
without emacs.
** Within Emacs
Emacs has a built-in package manager, ~package.el~. By default, its
sole repository is GNU's [[https://elpa.gnu.org][ELPA]] (Emacs Lisp Package Archive), but we can
just add some of our own:

#+begin_src emacs-lisp
  (require 'package)
  (set 'package-archives '(("gnu" . "https://elpa.gnu.org/packages/")))
  (add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/") t)
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
  (add-to-list 'package-archives '("nongnu" . "https://elpa.nongnu.org/nongnu/") t)
#+end_src

At this point, we can select packages for installation using the
~package-selected-packages~ variable, install those packages with
~package-install-selected-packages~, and load them with
~package-initialize~. Then, packages can be used right away just by
using them, or by explicitly using ~require~:

#+begin_src emacs-lisp :tangle no
  (setq package-selected-packages
        '(org-roam
          minibuffer-line
          fancy-battery
          xelb
          haskell-mode
          geiser
          ox-twbs
          yasnippet
          exwm
          htmlize
          org-babel-eval-in-repl
          paredit
          zenburn-theme
          avy
          slime
          sicp
          multiple-cursors
          exec-path-from-shell
          magit))
  (package-install-selected-packages)
  (package-initialize)
#+end_src

Doing this, however, separates the package installation,
loading, and configuration which defeats encapsulation and
scales poorly across machines. Instead, we can use ~use-package~:

#+begin_src emacs-lisp
  (when (not (package-installed-p 'use-package))
    (package-refresh-contents)
    (package-install 'use-package))
#+end_src

Now, ~use-package~ loads packages for use! In fact, ~use-package~ can
abstract not only package loading, but also package installation:

#+begin_src emacs-lisp
  (require 'use-package-ensure)
  (setq use-package-always-ensure t)
#+end_src

The benefits of use-package are package pinning and automatic
installation. See [[https://www.reddit.com/r/emacs/comments/8ua8e6/is_it_possible_specify_repository_preference_with/][this reddit thread]] for more.

** Within Guix
I don't yet have a good reason to manage my Emacs packages in
Guix. Managing packages within Emacs has the benefit of simplicity and
portability, so I'll continue managing packages in Emacs until there's
a good reason not to.

** Local Elisp
Any local 
#+begin_src emacs-lisp
  ; Local packages
  ;; Tell emacs where other config files are
  (setq site-lisp-dir
        (expand-file-name "site-lisp" user-emacs-directory))
  (add-to-list 'load-path site-lisp-dir)
  ;; Add local projects to load path
  (dolist (project (directory-files site-lisp-dir t "\\w+"))
    (when (file-directory-p project)
      (add-to-list 'load-path project)))
  (require 'spotify)
  (require 'vimgolf)
#+end_src

* Completion
Use company mode in all buffers:
#+begin_src emacs-lisp
  (use-package company :pin gnu)
  (add-hook 'after-init-hook 'global-company-mode)
#+end_src

* Project management
Use projectile everywhere:
#+begin_src emacs-lisp
  (use-package projectile :pin melpa-stable)
  (projectile-mode +1)
  (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
#+end_src

* Debugging
#+begin_src emacs-lisp
  (setq debug-on-error t)
#+end_src

* Dired
#+begin_src emacs-lisp
  (add-hook 'dired-mode-hook 'auto-revert-mode)
#+end_src

* LISP interaction
Let's highlight matching parens. ~blink-matching-parens~ controls
highlighting of parens immediately after insertion; ~show-paren-mode~
is a minor mode that controls highlighting of parens based on cursor
placement:
#+begin_src emacs-lisp
(show-paren-mode 1)
#+end_src
Use this to refactor adding of hooks:
#+begin_src emacs-lisp
    (setq lisp-mode-hooks '(scheme-mode-hook
                            emacs-lisp-mode-hook
                            clojure-mode-hook
                            cider-repl-mode-hook))
    (defun add-to-multiple-hooks (hooks function)
      (mapc (lambda (hook) (add-hook hook function)) hooks))
#+end_src
** Scheme
#+begin_src emacs-lisp
  (use-package geiser :pin nongnu)
  (use-package geiser-guile :pin nongnu)
#+end_src
** Paredit
#+begin_src emacs-lisp
  (add-to-multiple-hooks lisp-mode-hooks #'enable-paredit-mode)
#+end_src
#+begin_src emacs-lisp
  (defun my-paredit-shove-back ()
    "Like paredit-forward-slurp-sexp, but with point on the sexp to
  be slurped rather than the sexp to be slurped into."
    (interactive)
    (save-excursion
      (paredit-backward)
      (paredit-forward-down)
      (paredit-forward-slurp-sexp)))
#+end_src
#+begin_src emacs-lisp
  (add-hook 'paredit-mode-hook
	    (lambda () (local-set-key (kbd "C-M-(") #'paredit-wrap-round)))
#+end_src
** Rainbow Parens
#+begin_src emacs-lisp
  (use-package rainbow-delimiters :pin melpa-stable)
  (add-to-multiple-hooks lisp-mode-hooks #'rainbow-delimiters-mode)
#+end_src
** Clojure/ClojureScript
#+begin_src emacs-lisp
  (defvar etags-clj-cljs-regexp
    (concat "etags " "--regex='/[ \t\(]*def[a-z]* \([a-z!-]+\)/\1/' "
                     "--regex='/[ \t\(]*ns \([a-z.]+\)/\1/'"))

  ;; Recursively generate tags for all *.clj files, 
  ;; creating tags for def* and namespaces
  (defun create-clj-tags (dir-name)
    "Create tags file."
    (interactive "DDirectory: ")
    (shell-command
     (format "find %s \! -name '.*' -name '*.clj' | xargs %s"
             dir-name etags-clj-cljs-regexp)))

  ;; Recursively generate tags for all *.cljs files, 
  ;; creating tags for def* and namespaces
  (defun create-cljs-tags (dir-name)
    "Create tags file."
    (interactive "DDirectory: ")
    (shell-command
     (format "find . \! -name '.*' -name '*.cljs' | xargs %s"
             etags-clj-cljs-regexp)))

  ;; Recursively generate tags for all *.clj and *.cljs files, 
  ;; creating tags for def* and namespaces
  (defun create-clj-cljs-tags (dir-name)
    "Create tags file."
    (interactive "DDirectory: ")
    (shell-command
     (format "find %s \! -name '.*' -name '*.clj' -name '*.cljs' | xargs %s"
             dir-name etags-clj-cljs-regexp)))
#+end_src
#+begin_src emacs-lisp
  (use-package html-to-hiccup)
#+end_src
#+begin_src emacs-lisp
  (use-package clojure-mode)
  (use-package cider)
  (setq nrepl-use-ssh-fallback-for-remote-hosts 't)
#+end_src
#+begin_src emacs-lisp
  (add-hook 'clojure-mode-hook
            (lambda ()
              (set-fill-column 80)))
#+end_src
* Templates
#+begin_src emacs-lisp
(use-package yasnippet)
  (setq yas-snippet-dirs '("~/.emacs.d/snippets"))
  (add-hook 'scheme-mode-hook #'yas-minor-mode)
  (yas-reload-all)
#+end_src

* Helm
#+begin_src emacs-lisp
  (use-package helm)
  (global-set-key (kbd "M-x") #'helm-M-x)
  (global-set-key (kbd "C-x r b") #'helm-filtered-bookmarks)
  (global-set-key (kbd "C-x C-f") #'helm-find-files)
  (global-set-key (kbd "C-x b") #'helm-buffers-list)
  (helm-mode 1)
#+end_src

I use helm-org for ~helm-org-agenda-files-headings~
#+begin_src emacs-lisp
  (use-package helm-org :pin melpa-stable)
#+end_src

Helm-swoop is an improved searching interface:
#+begin_src emacs-lisp
  (use-package helm-swoop :pin melpa-stable)
  (global-set-key (kbd "M-i") 'helm-swoop)
  (global-set-key (kbd "M-I") 'helm-swoop-back-to-last-point)
  (global-set-key (kbd "C-c M-i") 'helm-multi-swoop)
  (global-set-key (kbd "C-x M-i") 'helm-multi-swoop-all)

  ;; When doing isearch, hand the word over to helm-swoop
  (define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch)
  ;; From helm-swoop to helm-multi-swoop-all
  (define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop)

  ;; Instead of helm-multi-swoop-all, you can also use helm-multi-swoop-current-mode
  (define-key helm-swoop-map (kbd "M-m") 'helm-multi-swoop-current-mode-from-helm-swoop)

  ;; Move up and down like isearch
  (define-key helm-swoop-map (kbd "C-r") 'helm-previous-line)
  (define-key helm-swoop-map (kbd "C-s") 'helm-next-line)
  (define-key helm-multi-swoop-map (kbd "C-r") 'helm-previous-line)
  (define-key helm-multi-swoop-map (kbd "C-s") 'helm-next-line)

  ;; Save buffer when helm-multi-swoop-edit complete
  (setq helm-multi-swoop-edit-save t)

    ;; Split direcion. 'split-window-vertically or 'split-window-horizontally
  (setq helm-swoop-split-direction 'split-window-vertically)

  ;; If nil, you can slightly boost invoke speed in exchange for text color
  (setq helm-swoop-speed-or-color nil)

  ;; ;; Go to the opposite side of line from the end or beginning of line
  (setq helm-swoop-move-to-line-cycle t)

  ;; Optional face for line numbers
  ;; Face name is `helm-swoop-line-number-face`
  (setq helm-swoop-use-line-number-face t)

  ;; If you prefer fuzzy matching
  (setq helm-swoop-use-fuzzy-match t)
  #+end_src
* Desktop interaction
#+begin_src emacs-lisp
  ;;(setq-default mode-line-format nil)

  (setq temp-max 25000)
  (setq temp-min 1000)
  (setq temp-default 2500)
  (setq temp-step 100)
  (setq temp temp-default)

  (setq brightness-default 0.5)
  (setq brightness brightness-default)
  (setq brightness-step 0.05)
  (setq brightness-max 1.0)
  (setq brightness-min 0.1)

  (defun temp-string () (format "%dK" temp))

  (defun redshift-update ()
    (start-process "" nil "redshift" "-P"
                   "-O" (temp-string)
                   "-b" (number-to-string brightness)))

  ;; What's a more lispy way of doing these redshift increment/decrement
  ;; functions? A HOF that does a "bounded-add"? 
  (defun temp-increment ()
    (interactive)
    (setq temp (min (+ temp temp-step)
                    temp-max))
    (redshift-update)
    (minibuffer-line--update))

  (defun temp-decrement ()
    (interactive)
    (setq temp (max (- temp temp-step)
                    temp-min))
    (redshift-update)
    (minibuffer-line--update))

  (defun brightness-increment ()
    (interactive)
    (setq brightness (min (+ brightness brightness-step)
                          brightness-max))
    (redshift-update)
    (minibuffer-line--update))

  (defun brightness-decrement ()
    (interactive)
    (setq brightness (max (- brightness brightness-step)
                          brightness-min))
    (redshift-update)
    (minibuffer-line--update))
  (setq minibuffer-line-refresh-interval 1)

  (setq minibuffer-line-format
          '(" "
           (:eval
            (format-time-string "%m/%d/%Y %T"))
           " | 🔋 "
           (:eval
            (battery-format "%p" (funcall battery-status-function)))
           "%% | "
           (:eval
            (format "%.2d" (* brightness 100)))
           "%% | "
           (:eval (temp-string))
           " | "
           ))

  ;;(setq mode-line-format nil)
  (setq-default mode-line-format '("%e" mode-line-front-space mode-line-mule-info mode-line-client mode-line-modified mode-line-remote mode-line-frame-identification mode-line-buffer-identification "   " mode-line-position
                           (vc-mode vc-mode)
                           "  " mode-line-modes mode-line-misc-info mode-line-end-spaces))
  #+end_src

* Appearance
If these are put in early-init.el then the frame briefly appears as
less than full screen, then expands (when starting with
emacsclient, at least). if started with emacs, then the frame stays
invisible.

#+begin_src emacs-lisp :tangle no
  (add-to-list 'initial-frame-alist '(visibility . nil))
  (add-to-list 'default-frame-alist '(fullscreen . maximized))
#+end_src

#+begin_src emacs-lisp
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (if (string-equal system-type "darwin")
      (progn
        (add-to-list 'default-frame-alist '(font . "SF Mono-12"))
        (add-to-list 'default-frame-alist '(undecorated . t))
        (add-to-list 'default-frame-alist '(fullscreen . maximized))))
  ;; set transparency
  ;; https://lwn.net/Articles/88179/
  ;; first value is for active frame, second value is for inactive frame
  ;; (set-frame-parameter (selected-frame) 'alpha '(99 100))
  (setq ring-bell-function 'ignore)
#+end_src

#+begin_src emacs-lisp
(set-frame-parameter nil 'width 100)
#+end_src
#+begin_src emacs-lisp
  (use-package zenburn-theme
    :defer t)
  (load-theme 'zenburn t)
#+end_src

For some reason, this is causing problems, so I'm not exporting it:
#+begin_src emacs-lisp :tangle no
  (require 'font-lock)
  (use-package font-lock
    :init
    :custom-face
    (font-lock-comment-face ((t (:inherit font-lock-comment-face :italic t))))
    (font-lock-doc-face ((t (:inherit font-lock-doc-face :italic t))))
    (font-lock-string-face ((t (:inherit font-lock-string-face :italic t)))))
#+end_src

* Avy
See https://github.com/abo-abo/avy/wiki/defcustom.

#+begin_src emacs-lisp
  (setq avy-keys '(?f ?j ?d ?k ?s ?l ?a ?\; ?' ?v ?n ?c ?m ?x ?, ?z
		   ?. ?b ?/ ?t ?u ?r ?i ?e ?o ?w ?p ?q ?\[ ?5 ?7 ?4
		   ?8 ?3 ?9 ?2 ?0 ?1 ?- ?6 ?= ?\] ?\\ ?` ?F ?J ?D ?K
		   ?S ?L ?A ?: ?\" ?V ?N ?C ?M ?X ?< ?Z ?> ?B ?? ?T
		   ?U ?R ?I ?E ?O ?W ?P ?Q ?{ ?% ?& ?$ ?* ?# ?\( ?@
		   ?\) ?! ?_ ?^ ?+ ?} ?| ?~))
  (setq avy-case-fold-search nil)
  (global-set-key (kbd "H-j") 'avy-goto-char)
#+end_src

* Tabs and spaces
#+begin_src emacs-lisp
    (setq-default c-basic-offset 4)
    (setq-default indent-tabs-mode nil)
    (setq-default indicate-empty-lines t)
#+end_src

* Enable functions
#+begin_src emacs-lisp
  (put 'narrow-to-region 'disabled nil)
  (put 'upcase-region 'disabled nil)
#+end_src

* Auto-generated files
Emacs generates (sometimes) helpful files, but litters them across the
filesystem by default. Let's keep them all in one place.
** ~customize~
*** hi
#+begin_src emacs-lisp
  (setq custom-file (concat user-emacs-directory "/custom.el"))
#+end_src

* Backups and  autosaves
Emacs uses "autosaves" and "backups" to prevent unintended loss of
work. An autosave periodically saves the buffer of an open file, so
that work not-yet-written to the filesystem is retained in the event
that emac crashes. A backup is a copy of a file that you have written
to, from emacs, that ensures you retain the original file in the event
of an accidental file overwrite. We definitely want to keep both these
features, but we want to store all of the autosaves and backups in one
place so that they don't clutter up the filesystem:

#+begin_src emacs-lisp
  (setq backup-directory-alist `(("." . "~/.emacs.d/.backups"))
        auto-save-file-name-transforms `((".*", "~/.emacs.d/.autosaves/\\1" t)))
  (setq desktop-path '("~/.emacs.d/desktop"))
  (setq auto-save-interval 150)
#+end_src

* Persistence between sessions
#+begin_src emacs-lisp
  (desktop-save-mode 1)
#+end_src
* Keyboard Setup
** Hyper
Once we add the ~hyper~ modifier Note how many bindings we can have
for number keys! First, we have 10 number keys and 10 numbered
function keys. We then have 5 modifiers (control, shit, meta, super,
hyper) which can be chorded, and then for the function-number keys
(f1, f2 etc) we have 4 modifiers! Supposing we can reasonably use 3
modifiers with a keypress, that's 1 + 5 + 10 + 10 = 26 ways of
pressing a number key, and 1 + 5 + 10 = 15 ways of pressing a numbered
function key for a total of 26 + 15 = 41 ways of pressing a generic
"number" key. Insane!

*** MacOS
I have karabiner map space to fn globally. I then have emacs map fn to
hyper. However, OSX translates some keychords containing fn into
keychords without the fn key. I know of two such cases: fn+f3
translates to f3 (as do the other numbered fn keys) and fn+<left>
translates to <home> (the other arrows keys have similar
translations). Therefore, some of the keybindings below use the the
translation from OSX instead of a chord with H (<home> instead of
<H-left>, for example)

#+begin_src emacs-lisp
  (if (string-equal system-type "darwin")
      (setq ns-function-modifier 'hyper))
#+end_src

*** GNU/Linux
#+begin_src emacs-lisp
  (if (string-equal system-type "gnu/linux")
      (setq ns-right-control-modifier 'hyper))
#+end_src

** ASCII Redundancies
Since we're *never* (hopefully) in a TTY, we want to free up control
codes that correspond to characters that already exist on the
keyboard. Maybe one day when I switch to a 40% I'll go back on this,
but for now it would be cool to free up these keybindings.

But actually, it turns out doing so is a [[https://emacs.stackexchange.com/a/52334][huge fucking rabbit hole]], and
so I won't (dare to) proceed until I have reason to. 

* Git
#+begin_src emacs-lisp
  (use-package magit :pin melpa-stable)
  (global-set-key (kbd "H-g") 'magit-status)
  (setq magit-diff-paint-whitespace t)
  (setq magit-diff-paint-whitespace-lines 'all)
  (setq magit-diff-highlight-trailing t)
  (setq magit-diff-highlight-indentation '())
#+end_src
* Buffers
#+begin_src emacs-lisp
  (global-set-key (kbd "s-k") 'kill-this-buffer)
#+end_src

** Windows
#+begin_src emacs-lisp
  (global-set-key (kbd "s-0") 'delete-window)
  (global-set-key (kbd "s-1") 'delete-other-windows)
  (global-set-key (kbd "s-2") 'split-window-below)
  (global-set-key (kbd "s-3") 'split-window-right)
  (global-set-key (kbd "<S-f3>") 'kmacro-end-macro)
  (global-set-key (kbd "H-c") 'mc/edit-lines)
  (global-set-key (kbd "s-f") 'make-frame)
  (global-set-key (kbd "s-n") 'other-window)
  (defun prev-window ()
    (interactive)
    (other-window -1))
  (global-set-key (kbd "s-p") 'prev-window)
  (global-set-key (kbd "s-o") 'find-file)
  (global-set-key (kbd "s-[") 'previous-buffer)
  (global-set-key (kbd "s-]") 'next-buffer)
  (defun next-window-next-buffer ()
    (interactive)
    (other-window 1)
    (next-buffer)
    (prev-window))
  (defun next-window-prev-buffer ()
    (interactive)
    (other-window 1)
    (previous-buffer)
    (prev-window))
  (global-set-key (kbd "s-{") 'next-window-prev-buffer)
  (global-set-key (kbd "s-}") 'next-window-next-buffer)
#+end_src

The =s=-={= and =s=-=}= bindings don't work due to my macbook keyboard
rollover, but these do:

#+begin_src emacs-lisp
  (global-set-key (kbd "<C-s-268632091>") 'next-window-prev-buffer)
  (global-set-key (kbd "<C-s-268632093>") 'next-window-next-buffer)
#+end_src

*** EXWM
#+begin_src emacs-lisp
  (if (string-equal system-type "gnu/linux")
      (progn
        ;;(require 'exwm-systemtray)
        ;;(exwm-systemtray-enable)
        ;;(setq exwm-systemtray-height 16)
        (require 'exwm)
        (require 'exwm-config)
        (exwm-config-default)
        (exwm-enable)
        ;;(setq fancy-battery-show-percentage t)
        ;;(fancy-battery-mode)
        (exwm-input-set-key (kbd "<XF86MonBrightnessDown>")
                      (lambda ()
                        (interactive)
                        (shell-command "light -U 5; light")))
        (exwm-input-set-key (kbd "<XF86MonBrightnessUp>")
                      (lambda ()
                        (interactive)
                        (shell-command "light -A 5; light")))      
        (exwm-input-set-key (kbd "<XF86MonBrightnessDown>") 'brightness-decrement)
        (exwm-input-set-key (kbd "<XF86MonBrightnessUp>") 'brightness-increment)
        (exwm-input-set-key (kbd "<S-XF86MonBrightnessDown>") 'temp-decrement)
        (exwm-input-set-key (kbd "<S-XF86MonBrightnessUp>") 'temp-increment)))
#+end_src

* Org
First some org-wide defaults.

#+begin_src emacs-lisp
  (setq org-directory "~/Dropbox/")
  (add-hook 'org-mode-hook 'turn-on-auto-fill)
  (add-hook 'org-mode-hook 'org-indent-mode) ; does this toggle?
  (setq org-src-tab-acts-natively t) ;; Src block indentation was horrible
  (setq org-src-window-setup 'current-window)
  (setq org-refile-targets '((org-agenda-files :maxlevel . 4)))
  (setq org-refile-use-outline-path nil)
  (org-babel-do-load-languages
   'org-babel-load-languages '((scheme . t)))
  (setq org-list-allow-alphabetical t)
  (setq org-startup-folded 'fold)
#+end_src

- TODO look into org-tempo and fix this
#+begin_src emacs-lisp :tangle no
  (add-to-list 'org-structure-template-alist
               '("el" . "#begin_src emacs-lisp\n?\n#end_src"))
#+end_src
Add org-entities. See https://emacs.stackexchange.com/questions/36898/proper-way-to-add-to-org-entities-user
#+begin_src emacs-lisp
  (setq org-entities-user
        '(("apple" "\\cmdkey" nil "&#8984;" "<kbd>COMMAND</kbd>" "<kbd>COMMAND</kbd>" "⌘")))
  ;; https://emacs.stackexchange.com/questions/7323/how-to-add-new-markup-to-org-mode-html-export
  (setq org-html-text-markup-alist '((code . "<kbd>%s</kbd>")))
#+end_src

Display keyboard input properly in html: https://emacs.stackexchange.com/questions/7323/how-to-add-new-markup-to-org-mode-html-export
#+begin_src emacs-lisp
  (setq org-html-text-markup-alist '((code . "<kbd>%s</kbd>")))
#+end_src

Let's organize headings with tags:
#+begin_src emacs-lisp
  (setq org-tag-alist
        '(("emacs" . ?e)
          ("money" . ?m)
          ("social" . ?s)
          ("chore" . ?c)
          ("exercise" . ?x)
          ("chelm")))
#+end_src

#+begin_src emacs-lisp :tangle no
(use-package org-contrib)
(require 'ol-git-link)
#+end_src

#+begin_src emacs-lisp
  (setq org-special-ctrl-a/e t)
  (setq org-special-ctrl-k t) ; This isn't working
#+end_src

#+begin_src emacs-lisp
  (setq org-goto-interface 'outline-path-completion)
#+end_src

** Keybindings
Some good keybindings:
- =C=-=c= ='= for ~org-edit-special~

#+begin_src emacs-lisp
  (add-hook 'org-mode-hook
            (lambda ()
              (local-set-key (kbd "<C-M-return>") 'org-insert-subheading)))
  (global-set-key (kbd "H-c") 'org-capture)
  (global-set-key (kbd "C-c c") 'org-capture)
  (global-set-key (kbd "C-c r") 'org-refile)
  (global-set-key (kbd "C-c a") 'org-agenda)
#+end_src

** Org Babel
The manual says this is dangerous, but let's do it anyway:

#+begin_src emacs-lisp
  (setq org-confirm-babel-evaluate nil)
#+end_src

** Org Capture
I want to be able to put the cursor exactly one line below the optional properties
drawer. Using two newlines in the template almost works, but creates
two newlines.
#+begin_src emacs-lisp
  (setq org-capture-templates
                '(("s" "SICP Exercise" entry
                   (file "~/git/thoelze1.github.io/org/sicp-exercises.org")
                   "* %?")
                  ("j" "Journal" entry
                   (file (lambda () (concat org-directory "journal.org")))
                   "* %U\n%?" :clock-in t :clock-resume t)
                  ("q" "Quote" entry
                   (file (lambda () (concat org-directory "quotes.org")))
                   "* %?")
                  ("e" "Emacs feature" entry
                   (file+headline (lambda () (concat org-directory "projects.org")) "Emacs features")
                   "* TODO %?")
                  ("p" "Project" entry
                   (file (lambda () (concat org-directory "projects.org")))
                   "* TODO %?")
                  ("l" "Log" entry
                   (file (lambda () (concat org-directory "log.org")))
                   "* %U\n%?")
                  ("r" "Book" entry
                   (file+headline (lambda () (concat org-directory "reading.org")) "Books")
                   "* TODO %?")
                  ("m" "Miscellaneous" entry
                   (file (lambda () (concat org-directory "misc.org")))
                   "* TODO %?" nil nil)
                  ("b" "Blog post ideas" entry
                   (file (lambda () (concat org-directory "blog.org")))
                   "* %? ")
                  ("w" "Websites" entry
                   (file+headline (lambda () (concat org-directory "reading.org")) "Websites")
                   "* %? ")))
#+end_src

** Org Export/Publish
I have some custom functions that I use in the publishing process:

#+begin_src emacs-lisp
  (defun file-contents (filename)
    "Return the contents of FILENAME."
    (with-temp-buffer
      (insert-file-contents filename)
      (buffer-string)))

  (defun strings-to-regexp (&rest files)
    (rx-to-string (cons 'or files)))
#+end_src

Then, the code that I actually use to publish. This should really
belong with the data being published, as I noted in a blog post.

I use the ~org-export~ sitemap feature as a way of listing all of my
blog posts:

#+begin_src emacs-lisp
(defun org-publish-sitemap-function (title list)
  "Sitemap generation function."
  (concat "#+TITLE: Tanner Hoelzel\n"
          (file-contents "~/git/thoelze1.github.io/index-header.org")
          "* Blog\n"
          (org-list-to-org list)))

(defun org-publish-sitemap-format-entry (entry style project)
  (cond ((not (directory-name-p entry))
         (format "%s: [[file:%s][%s]]"
                 (format-time-string "%Y-%m-%d"
                                     (org-publish-find-date entry project))
                 entry
                 (org-publish-find-title entry project)))
        ((eq style 'tree)
         ;; Return only last subdir.
         (file-name-nondirectory (directory-file-name entry)))
        (t entry)))
#+end_src

#+begin_src emacs-lisp
  (setq org-twbs-head "
  <link  href=\"https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\">
  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\"></script>
  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js\"></script>
  ")
  ;; (setq org-twbs-preamble-format '(("en" "<p class=\"author\">%t</p>")))
  (setq org-export-with-toc 2)
  ;; https://miikanissi.com/blog/website-with-emacs.html
  ;; (setq website-header "~/git/thoelze1.github.io/org")
  (setq org-publish-project-alist
        '(("resume"
           :base-directory "~/git/resume"
           :publishing-directory "~/git/thoelze1.github.io"
           :base-extension nil
           :include ("resume.pdf")
           :publishing-function org-publish-attachment)
          ("content"
           :base-directory "~/git/thoelze1.github.io"
           :publishing-directory "~/git/thoelze1.github.io"
           :publishing-function org-html-publish-to-html
           :exclude "\\(?:index-header\\.org\\)" ;; (strings-to-regexp "index-header.org")
           :with-toc nil
           :html-postamble nil
           :section-numbers nil
           :auto-sitemap t
           :sitemap-function org-publish-sitemap-function
           :sitemap-title "Tanner Hoelzel"
           :sitemap-filename "index.org"
           :sitemap-style list
           :sitemap-sort-files anti-chronologically
           :sitemap-format-entry org-publish-sitemap-format-entry)
          ("website" :components ("resume" "content"))))
#+end_src

** Org Roam
#+begin_src emacs-lisp
  (use-package org-roam :pin melpa-stable)
  (setq org-roam-directory "~/Dropbox/org-roam")
#+end_src

** Org Agenda
Disclaimer: it seems that many things are difficult to do within ~org-agenda~:
- [[https://emacs.stackexchange.com/questions/31683/schedule-org-task-for-last-day-of-every-month][Repeating on the last day of each month]]
- [[https://emacs.stackexchange.com/questions/41446/org-mode-repeating-task-until][Repetition daily within a range]]
- [[https://karl-voit.at/2017/01/15/org-clone-subtree-with-time-shift/][Repeating on certain days of the week]]

Using the agenda allows scheduling future events, maintaining a todo
list, and logging tasks. Let's put it at hand:

#+begin_src emacs-lisp
(global-set-key (kbd "H-a") 'org-agenda-list)
(global-set-key (kbd "H-t") 'org-todo-list)
#+end_src

The agenda can be rebuild at any time ~org-agenda-redo~.

#+begin_src emacs-lisp
  (setq org-default-notes-file (concat org-directory "misc.org"))
  (setq org-agenda-files '("~/Dropbox/org-agenda/"))
  (setq org-agenda-start-on-weekday nil)
  (setq org-agenda-time-grid '((daily today require-timed)
                               (800 1000 1200 1400 1600 1800 2000)
                               "......" "----------..."))
#+end_src

I use tags to categorize items more than filenames:

#+begin_src emacs-lisp
  (setq org-agenda-prefix-format
        ' ((agenda . " %i %-12:c%?-12t% s")
           (todo . " %-8:T ")
           (tags . " %i %-12:c")
           (search . " %i %-12:c")))
#+end_src

Let's add some custom views:

#+begin_src emacs-lisp
(setq org-agenda-custom-commands
      '(("c" . "My Custom Agendas")
        ("cu" "Unscheduled TODO"
         ((todo ""
                ((org-agenda-overriding-header "\nUnscheduled TODO")
                 (org-agenda-skip-function '(org-agenda-skip-entry-if 'timestamp)))))
         nil
         nil)))
#+end_src

*** Scheduling events
Scheduling future events is accomplished simply by adding a timestamp
to an org entry. The schedule can then be viewed with ~org-agenda~.

Some tips for org "habits":
https://lists.gnu.org/archive/html/emacs-orgmode/2010-09/msg00406.html

#+begin_src emacs-lisp
(add-to-list 'org-modules 'org-habit)
#+end_src

*** Logging time
:LOGBOOK:
CLOCK: [2022-03-04 Fri 16:47]--[2022-03-04 Fri 16:48] =>  0:01
:END:
Logging tasks can be accomplished by clocking in and out with the
desired keybindings. You can view a log of your day at any time with
~org-agenda-log-mode~.

Clocking in and out is done a lot, so let's make those single
keystrokes:

#+begin_src emacs-lisp
(global-set-key (kbd "H-i") 'org-clock-in)
(global-set-key (kbd "H-o") 'org-clock-out)
#+end_src

I also like to add notes to tasks as I complete them:

#+begin_src emacs-lisp
  (setq org-log-note-clock-out 't)
#+end_src

You can see clock time with ~org-agenda-clockreport-mode~.

It is possible to clock out of a task by marking that task as
completed, but this doesn't prompt for a log note.

#+begin_src emacs-lisp
(setq org-clock-out-when-done t)
#+end_src

Searching for the item that you intend to clock into wastes time. By
using helm, we can improve the clocking interface:

#+begin_src emacs-lisp
  (defun my-org-clock-in (prefix)
    (interactive "P")
    ;;(message "%s" prefix)
    (if prefix
        (save-window-excursion
          (let ((original-buffer (current-buffer)))
            (helm-org-agenda-files-headings)
            (if (not (eq original-buffer (current-buffer)))
                (org-clock-in))))
      (org-clock-in)))

  (global-set-key (kbd "H-i") 'my-org-clock-in)
#+end_src

*** Managing TODOs
By default, TODOs have two states: TODO and DONE. We can use our own
states, with different state spaces for different types of tasks:

#+begin_src emacs-lisp
  (setq org-todo-keywords-tasks
        '(sequence "TODO(t!)" "|" "WAITING(w!)" "DONE(d!)" "CANCELED(c!)"))
  (setq org-todo-keywords-billing
        '(sequence "OWED(o)" "|" "BILLED(b!)" "PAID(p)"))
  (setq org-todo-keywords
        (list org-todo-keywords-tasks
              org-todo-keywords-billing))
#+end_src

The ~(!)~ after ~DONE~ is *required* for a note to be recorded when a
task moves into the ~DONE~ state. Let's hide state changes in the same
drawer that we clock time with:

#+begin_src emacs-lisp
  (setq org-log-into-drawer t)
#+end_src

~org-todo-keywords~ is made up of lists of lists: I can add a new list
of keywords if a new type of task corresponds to a different set of
states!

TODOs should have priority values so that the most important are
automatically brought to attention.

#+begin_src emacs-lisp
  (setq org-priority-highest 1)
  (setq org-priority-lowest 9)
  (setq org-priority-default 5)
#+end_src

Now, items shown from ~org-todo-list~ are sifted by priority value.

#+begin_src emacs-lisp
  (setq org-enforce-todo-dependencies t)
#+end_src

A problem: I have a recurring calendar item that I want to appear in
the agenda 

#+begin_src emacs-lisp
  (setq org-agenda-todo-ignore-scheduled t)
#+end_src

* Custom functions
#+begin_src emacs-lisp
  (global-set-key (kbd "s-<backspace>")
                  (lambda () (interactive) (if (= (current-column) 0)
                                   (backward-delete-char 1) (kill-line 0))))

  (defun copy-sexp ()
    (interactive)
    (save-window-excursion
      (save-excursion
        (avy-goto-char ?\()
        (mark-sexp)
        (kill-ring-save (point) (mark))
        (pop-mark)
        (pop-mark))))
  (global-set-key (kbd "C-c C-M-@") 'copy-sexp)
#+end_src

* MacOS Quirks
Not sure if this is still necessary?

#+begin_src emacs-lisp
  (add-hook 'emacs-startup-hook (lambda () (make-frame-visible)))
#+end_src

#+begin_src emacs-lisp
  (setq inferior-lisp-program "/opt/local/bin/sbcl")
#+end_src

* Environment variables
There are a few scenarios where emacs inherits a default set of
environment variables rather than the complete set you want it to:
- Launching Emacs as GUI app on OS X
- Launching Emacs as daemon from launchd or systemd

In such cases, we can use [[https://github.com/purcell/exec-path-from-shell][exec-path-from-shell]]. This loads environment
variables from your shell. Because of how shells work, it loads from
~.zshenv~ rather than ~.zshrc~. So for everything to work, you must
both put your environment variables in ~.zshenv~ and call
~exec-path-from-shell-initialize~:

Read this at some point:
https://blog.flowblok.id.au/2013-02/shell-startup-scripts.html

** Initializing Environment Variables
#+begin_src emacs-lisp
  (if (string-equal system-type "darwin")
      (when (memq window-system '(mac ns x))
        (exec-path-from-shell-initialize)));
#+end_src

** Updating Environment Variables
Use ~exec-path-from-shell-copy-env~

** Inspecting Environment Variables
Use ~getenv~

* Linux Quirks
This fixes som security issue on linux (forget the link), and an issue
on mac:
- https://emacs.stackexchange.com/questions/68288/error-retrieving-https-elpa-gnu-org-packages-archive-contents

#+begin_src emacs-lisp
  (setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3")
#+end_src

* GPG
#+begin_src emacs-lisp
  (require 'epa-file)
  (custom-set-variables '(epg-gpg-program  "/usr/local/bin/gpg"))
  (epa-file-enable)
#+end_src

* Text editing
* Syntax Highlighting
#+begin_src emacs-lisp
  (use-package osx-plist :pin melpa-stable)
#+end_src

* Breaking a long string literal into lines
** First Attempts
#+begin_src emacs-lisp
  (global-set-key (kbd "H-5") 'paredit-str-reindent)
  (global-set-key (kbd "H-6") (lambda ()
                                (interactive)
                                (message
                                 (number-to-string (line-length)))))

  (defun dec (x) (- x 1))

  (defun line-length ()
    (let ((eol-pos (line-end-position)))
      (dec (if (= (line-number-at-pos) 1)
               eol-pos
             (- eol-pos (line-end-position 0))))))


  ""

  (defun paredit-sexp-multilinep ()
    (interactive)
    (save-excursion
      (paredit-backward-up)
      (let ((current-line (line-number-at-pos)))
        (paredit-forward)
        (not (= current-line (line-number-at-pos))))))


  (defun paredit-str-block-reindent ()
    (paredit-backward-up)
    (paredit-forward-down)
    (paredit-forward)
    (while (let ((curr (point)))
             (save-excursion
               (paredit-forward-up)
               (paredit-backward-down)
               (< (point) curr)))
      (paredit-forward)
      (paredit-join-sexps)
      ))
  (defun paredit-str-reindent ()
    (interactive)
    (paredit-backward-up)
    (paredit-open-round)
    (insert "str ")
    (paredit-forward-slurp-sexp)
    (forward-char)
    (paredit-reindent-defun)
    (while (paredit-sexp-multilinep)
      (move-end-of-line)
      (insert " ")
      (while (> (+ 1 (line-length)) fill-column)
        (backward-word))
      (paredit-split-sexp)
      (delete-char 1)
      (insert "\n")))

  (defun paredit-str-reindent ()
    (interactive)
    (paredit-backward-up)
    (paredit-open-round)
    (insert "str ")
    (paredit-forward-slurp-sexp)
    (forward-char)
    (clojure-fill-paragraph)
    (while (paredit-sexp-multilinep)
      (let (()))
      (move-end-of-line nil)
      (insert "__")
      (clojure-fill-paragraph)
      (paredit-backward-up)
      (forward-char)
      (delete-char 1)
      (move-end-of-line nil)
      (paredit-split-sexp)
      (delete-char 1)
      (insert "\n")
      (forward-char)
      (delete-horizontal-space)
      (delete-char 1)
      (delete-horizontal-space)
      (indent-for-tab-command)))
#+end_src
** A Functional Approach
#+begin_src emacs-lisp
  (defun region-to-string ()
    (buffer-substring-no-properties (region-beginning) (region-end)))

  (defun paredit-string-literal-to-string ()
    (if (paredit-in-string-p)
        (paredit-backward-up))
    (mark-sexp)
                                          ; (kill-region 0 0 t) ; BEG
                                          ; and END cannot be nil (this
                                          ; is a bug in emacs
                                          ; documentation)
                                          ; (current-kill 0 t)
    (let ((s (region-to-string)))
      (delete-region (region-beginning) (region-end))
      s))

  (defun paredit-break-str (str)
    (let* ((str (paredit-string-literal-to-string))
           (strs (break-string str)))
      (put-string-back-into-buffer strs)))

#+end_src
** Working library
#+begin_src emacs-lisp
  (defun line-too-long-p ()
    (> (line-length) fill-column))

  (defun move-to-line-break ()
    ;; Move forward one "word"
    (re-search-forward " ")
    ;; If we're beyond fill-column, we'll split here. If not, we want to
    ;; split at the last word-delimiter (space) before fill-column.
    (if (< (current-column) (dec fill-column))
        (progn
          (move-to-column (dec fill-column))
          (re-search-backward " ")
          (forward-char))))

  (defun split-line ()
    (paredit-split-sexp)
    (delete-char 1)
    (insert "\n")
    (forward-char))

  (defun prev-sexp-string-p ()
    (save-excursion
      (paredit-backward)
      (forward-char)
      (paredit-in-string-p)))

  (defun next-sexp-string-p ()
    (save-excursion
      (paredit-forward)
      (paredit-forward)
      (prev-sexp-string-p)))

  (defun join-strs-around-point ()
    "Joins all adjacent string literals around point."
    (interactive)
    (if (paredit-in-string-p)
        (paredit-backward-up))
    ;; Move backward to first string literal
    (while (prev-sexp-string-p)
      (paredit-backward))
    ;; Now join all following strs
    (while (next-sexp-string-p)
      (paredit-forward)
      (paredit-join-sexps)
      (paredit-backward-up)))

  (defun paredit-fill-str ()
    "Break string-literal(s) around point into shorter components,
  maximizing line-width without exceeding fill-column. Similar to
  `fill-paragraph', but does not alter whitespace of string literal.

  Assumes that:
    - point is within or at start of a string literal
    - string literal already has the desired indentation
    - string literal does not contain tabs or newlines"
    (interactive)
    (join-strs-around-point)
    (forward-char)
    ;; Now we repeatedly split the string until it fits. There is still
    ;; an unhandled case where the final line is too long due to
    ;; characters following the string...
    (while (line-too-long-p)
      (move-to-line-break)
      (split-line)
      (indent-for-tab-command))
    ;; Move point to end of string
    (paredit-forward-up))
#+end_src
* Python
#+begin_src emacs-lisp
(setq python-shell-interpreter "python3")
#+end_src
Now we can use ~C-c c-p~ to start a python REPL from a python buffer.
